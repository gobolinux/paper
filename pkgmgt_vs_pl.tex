%% LyX 2.3.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english,format=sigplan,10pt]{acmart}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{array}
\usepackage{verbatim}
\usepackage{graphicx}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\acmConference{PLOS 2019}{October 29, 2019}{Huntsville, Canada}
\acmMonth{10}
\acmYear{2019}
\copyrightyear{2019}
\setcopyright{acmlicensed}
\settopmatter{printacmref=false}

\makeatother

\usepackage{babel}
\begin{document}
\title[Taxonomy of Package Management]{Taxonomy of Package Management\\
in Programming Languages and Operating Systems}
\author{Hisham Muhammad}
\affiliation{Kong Inc.}
\email{hisham@konghq.com}
\author{Lucas C. Villa Real}
\affiliation{IBM Research}
\email{lucasvr@br.ibm.com}
\author{Michael Homer}
\affiliation{Victoria University of Wellington - Wellington, New Zealand}
\email{mwh@ecs.vuw.ac.nz}
\begin{abstract}
Package management is instrumental for programming languages and operating
systems, and yet it is neglected by both areas as an implementation
detail. For this reason, it lacks the same kind of conceptual organization:
we lack terminology to classify them or to reason about their design
trade-offs. In this paper, we share our experience in both OS and
language-specific package manager development, categorizing families
of package managers and discussing their design implications beyond
particular implementations. We also identify possibilities in the
still largely unexplored area of package manager interoperability.
\end{abstract}
\keywords{\noindent package management, operating systems, module systems, filesystem
hierarchy}
\maketitle

\section{Introduction}

Package managers are programs that map relations between files and
packages (which correspond to sets of files), and between packages
(dependencies), allowing users to perform maintenance of their systems
in terms of packages rather than at the level of individual files.
Package management is an area that lies somewhere in the border between
programming languages and operating systems: packaging is a step that
sits after a language's build process, and before an operating system's
component installation. For this reason, it seems to be overlooked
by both fields as an implementation issue. In the meantime, package
management keeps growing in complexity. New languages, new deployment
models, and new portability requirements all give rise to new package
management systems. Further, this is not simply a matter of competing
implementations: modern complex environments often require several
package managers to be used in tandem.

For example, when writing JavaScript web applications on a Mac environment,
a developer may require using Bower \citep{bower}, a package manager
for client-side JavaScript components. Bower is installed using \texttt{npm}
\citep{npm}, a package manager for \texttt{node.js} \citep{nodejs},
a JavaScript environment. On a Mac system, the typical way to install
command-line tools such as \texttt{npm} is via either Homebrew \citep{homebrew}
or MacPorts \citep{macports}, the two most popular general-purpose
package managers for macOS. This is not a deliberately contrived example;
it is the regular way to install development modules for a popular
language in a modern platform.

\begin{comment}
In \citep{Burns2012Deploying} we have another example of a typical
software stack, where a deployment and management scenario for Ruby
on Rails applications is described combining a number of tools. It
uses Vagrant \citep{Hashimoto2013Vagrant} for virtual machine management;
Puppet \citep{Arrundel2011Puppet} for editing system configuration
files and driving the system-wide package manager on servers; Capistrano
for deploying the Ruby on Rails application, including installing
Ruby scripts and migrating database tables, driving RubyGems, the
language-specific package manager for Ruby modules (with Bundler to
mitigate module version conflicts); and RVM for managing conflicting
versions of Ruby itself. It is interesting to note the number of different
tools being used on top of each other to manage containment and compatibility
issues on various layers; and again, this is a typical, realistic
scenario.
\end{comment}

The combinations of package managers change as we move to a different
operating system or use a different language. Learning one's way through
a new language or system, nowadays, includes learning one or more
packaging environments. As a developer of modules, this includes not
only using package managers but also learning to deploy code using
them, which includes syntaxes for package specification formats, dependency
and versioning rules and deployment conventions. Simply ignoring these
environments and managing modules and dependencies by hand is tempting,
but the complexity of heterogeneous environments and keeping track
of dependency updates can become burdensome --- all these package
managers were created to solve practical problems which the developer
would have to otherwise directly handle, after all. Another alternative
that is often proposed, especially by users of operating systems that
feature a system-provided package manager (as is the case of most
Linux distributions), is to avoid using multiple package managers
and use a single general-purpose package manager. This is, of course,
as much of a solution as trying to make everyone agree on a single
programming language --- one of many analogies between package management
and programming languages. The result is that the ecosystem is not
getting any simpler, and at first glance it seems that package management
is indeed a largely unsolved problem.

However, maybe the statement ``package management is an unsolved
problem'' simply does not make sense, and is akin to saying that
``programming languages are an unsolved problem''. In the programming
languages world we accept that the multitude of languages is a given.
Beyond that, we understand that there are families of languages with
different paradigms, with well-known tradeoffs. We also accept that
there is room for domain-specific languages (DSLs) and for general-purpose
languages. Most importantly, we know how to set boundaries for each
language and how to make DSLs and general-purpose languages interact.
Most existing package management systems, however, are still oblivious
to the fact that they exist as part of a larger ecosystem, with parts
of it handled by other package managers.

In this paper we draw on our own unique combination of experiences
on all sides of this topic: developing a system-wide package manager
for a Linux distribution \citep{Muhammad2002WSL,Homer2010LCA}, creating
a language-specific package manager \citep{Muhammad2013LuaRocks},
and integrating system and language-specific package managers \citep{Homer2010LCA},
as well as being simply developers and end users of other software.
By building a taxonomy for package management and sharing our experiences
with package management development in both the programming language
and operating system spaces, we aim in this paper to frame the design
choices, layers, and trade-offs attendant to package managers for
developers, maintainers, and users.

\vspace{-0.2em}


\section{Paradigms of package management: filesystem-oriented vs. database-oriented}

It is a typical didactic device to organize the landscape of programming
languages into paradigms, such as imperative, functional, object-oriented,
and so on. %
\begin{comment}
These paradigms describe the core conceptual frameworks on top of
which languages are designed. 
\end{comment}
The paradigms a language is categorized into inform users about particular
design choices, and with these choices come design trade-offs. In
the world of package managers, we can also identify general paradigms,
by looking at their core concepts and design trade-offs. Package managers
map between files and packages, and between packages and their dependencies,
allowing users to perform maintenance of their systems in terms of
packages rather than at the level of individual files. The central
design choice in a package manager, therefore, is how to perform those
mappings.

There are two approaches on how to map files to packages: the mapping
can be based on the hierarchical directory structure where the files
reside, or can be separate. As this choice embodies a series of trade-offs
and is the single decision that affects the design and implementation
of a package manager the most, we identify these as two paradigms
of package management. When the mapping is internal to the file hierarchy
structure, we say that package management is \emph{filesystem-oriented}\footnote{Being database-oriented does not imply an opaque, binary database
format. Various database-oriented package managers store their file
manifests in plain text files}. When it is external to the hierarchy of files being managed, the
mapping needs to be stored elsewhere. We say in these cases that management
is \emph{database-oriented}. Most package managers for Linux distributions,
such as RPM and dpkg/APT, are database-oriented. Filesystem-oriented
package management is more often seen in language-specific package
managers, but as we will see in Section \ref{subsec:GoboLinux}, it
can also be performed system-wide.

The directory structure used by \texttt{pip}, the package manager
for Python modules, is representative of the database-oriented style.
Modules installed by \texttt{pip} are stored under a filesystem
path that conforms to Python's default directory for locally-installed
modules (e.g. \texttt{/usr/lib/python3.7/site-pack\-ages/}), whose definition
predates the introduction of \texttt{pip}. Database-oriented
designs are often chosen when the package manager needs to accomodate
a pre-existing directory structure. If Python packages have modules
with the same name, clashes may occur. In a filesystem-oriented design,
such as for example that of RubyGems, this problem would not happen.
Each package has its own subtree under a versioned directory, and
the \texttt{rubygems.rb} module, part of the default installation
of Ruby, takes care of finding the appropriate files when modules
are loaded with the \texttt{require} function. Figure \ref{fig:pm-taxonomy}
lists more examples of package managers and their classification.

\begin{comment}
Initially it may seem that this is an implementation detail, and
that this distinction is, or should be, transparent to users of package
managers. As long as they can type a command to install a package
and then launch the program or load the library, how the manager keeps
its consistency is irrelevant. While this is true for end-users installing
packages and using applications and libraries, it is not true for
another category of users of package managers: those who do the packaging
of programs. In other words, this is akin to saying that on one hand
end-users of applications shouldn't care what language they are written
in, but on the other hand the language paradigm affects those who
write programs greatly.
\end{comment}

The major trade-off between the filesystem-oriented and the database-oriented
approaches is whether applications should be aware of the file structure
defined by the manager or whether the manager should adapt to the
file structure defined by applications. This affects how the manager
tracks the mapping of files and how applications are configured to
find their resource files. 

In filesystem-oriented managers the mapping of files to packages is
simple. File conflicts are naturally avoided by storing files of different
packages in separate subtrees. Versioning conflicts between variants
of the same package can also be handled via the tree structure. The
structure also becomes more transparent to users, which can simplify
their experience. The run-time lookup of files by applications, however,
can be complicated, if they are oblivious to the structure defined
by the package manager. Applications must either agree beforehand
to this structure (which might be an option in domain-specific environments),
or the package manager has to do extra work to configure them to use
the structure, such as setting configuration options or environment
variables, or in the worst case, patching them.

Conversely, in database-oriented managers the mapping of files to
packages is more complicated. Applications may install files wherever
they please, and the package manager needs to keep track. This includes
handling potential conflicts if two packages want to use the same
pathname. Database-oriented systems will usually report on these conflicts
and forbid them. It is up to the integrator (such as a distribution
developer) who is building packages to resolve the conflict somehow.
Also, the package manager needs to verify that the database and the
contents of the filesystem remain in sync, which is trivial in the
filesystem-oriented approach. The run-time lookup of files on database-oriented
systems, on its turn, is greatly simplified. In most cases it will
be a non-issue, since each file is in the location the application
expected it to be in the first place. However, it does become an issue
when the file has been relocated by the integrator who built the package,
perhaps for solving conflicts.

\begin{comment}

Repository maintainers of database-oriented package managers often
solve versioning conflicts by resorting to filesystem-oriented approaches.
For example, the maintainer of Debian packages for the Lua virtual
machine patches its Makefile to install C headers under versioned
directories such as \texttt{/usr/include/lua5.3}, to avoid conflicts
of simultaneous Lua versions in the system installing \texttt{lua.h}.
Such changes propagate to users of these packages: Lua-based software
such as LuaRocks \citep{Muhammad2013LuaRocks} and Prosody \citep{prosody}
include code in their installation scripts specifically to handle
Debian locations. Meanwhile, FreeBSD uses \texttt{/usr/include/lua53}
and NetBSD uses \texttt{/usr/include/lua-5.3}. To reduce this kind
of incompatibility among downstream distributors, many upstream maintainers
adopt hierarchical versioning structures themselves: C headers for
Python, for example, install into versioned directories such as \texttt{/usr/include/python3.7}
by default in every system. It is unclear, however, which packages
are the ones where users will desire to keep simultaneously installed
versions and which are not; one might ask why \emph{all} C headers
aren't installed in a versioned way. In fact, when we look at Unix
shared libraries, we see that this is the case: the standard practice
is to install libraries in versioned files such as \texttt{libfoo.so.1},
with a \texttt{libfoo.so} symbolic link for user convenience. Note
that, as typical of filesystem-oriented approaches, there needs to
be some cooperation for run-time lookup, and indeed the dynamic linker
is aware of this structure and makes use of versioned filenames.
\end{comment}

Filesystem-oriented managers also present their own set of challenges,
as the description of packages as set of files does not present a
full picture. Packages, especially in system-wide installations, often
need to perform global changes to the system, such as adding users
and setting environment variables. Some applications also include
database-oriented portions which are assumed to be updated by installation
scripts, such as refreshing global caches. Non-relocatable packages
often assume hardcoded default paths in which resource files are expected
to be found; if the package manager employs a different organization,
it needs to reconfigure applications to make sure the required files
are found. One common solution is to use environment variables, since
applications often support setting custom paths via variables in addition
to the system-wide defaults. Most applications can be installed in
custom locations, with the installation prefix being adjustable at
compile time. The \texttt{/opt} directory is a traditional location
for filesystem-oriented organization of additional packages. Core
system services are often harder to relocate.

To use the filesystem or a database is a frequent design dilemma beyond
package management, especially on Unix systems, where ``everything
is a file'' is a long-standing tradition. %
\begin{comment}
Different styles of bootscripts on Unix employ one or the other approach,
with System V being the archetypical file-hierarchy-based init system
and BSD init using \texttt{/etc/rc.conf} as a central configuration
file. Program configuration can either use on separate text-based
configuration files under \texttt{/etc} or a central registry of settings,
such as GConf \citep{Pennington2002GConf}. In modern Linux distributions,
the package manager is the most central component for organizing the
operating system. 
\end{comment}
Database-oriented solutions often are considered un-Unix-like (GConf,
for instance, raises comparisons to the Windows Registry \citep{Wallen2003GConfWin}).
It is remarkable that, in spite of the Unix philosophy, most Linux
package managers are primarily database-oriented.

\begin{figure*}[t]
\begin{centering}
\begin{tabular}{|c|c|c|}
\cline{2-3} \cline{3-3} 
\multicolumn{1}{c|}{} & {\footnotesize{}Filesystem-oriented} & {\footnotesize{}Database-oriented}\tabularnewline
\hline 
{\footnotesize{}Language-agnostic} & {\footnotesize{}}%
\begin{tabular}{c}
{\footnotesize{}Homebrew (macOS), GNU Stow, Nix,}\tabularnewline
{\footnotesize{}Encap, PBI 8 (PC-BSD), GoboLinux}\tabularnewline
\end{tabular} & {\footnotesize{}}%
\begin{tabular}{c}
{\footnotesize{}RPM (RedHat/Fedora/etc.), dpkg/apt (Debian/Ubuntu/etc.)}\tabularnewline
{\footnotesize{}PBI 9 (PC-BSD), Pacman (ArchLinux)}\tabularnewline
\end{tabular}\tabularnewline
\hline 
{\footnotesize{}Language-specific} & {\footnotesize{}}%
\begin{tabular}{c}
{\footnotesize{}npm (server-side JavaScript), Bower (client-side JavaScript)}\tabularnewline
{\footnotesize{}RubyGems (Ruby), Cargo (Rust), LuaRocks 1.x (Lua)}\tabularnewline
\end{tabular} & {\footnotesize{}}%
\begin{tabular}{c}
{\footnotesize{}Cabal (Haskell), pip (Python), LuaRocks 2.x (Lua)}\tabularnewline
\end{tabular}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{\label{fig:pm-taxonomy}A package manager taxonomy, with representative
examples}
\end{figure*}

\begin{comment}
\textbf{Other filesystem-based approaches}

One of the earliest filesystem-oriented package managers to note is
GNU Stow \citep{stow}, which inherited ideas from Carnegie Mellon's
Depot \citep{Colyer1992Depot}. Stow focuses on the management of
programs installed on non-regular paths (e.g. on some user's home
directory, on external devices, etc). Given the path to one such program
tree, Stow ``activates'' it on the system by creating symbolic links
to the program's contents at a central location such as \texttt{/usr/local}.
Existing symbolic links are expanded with directories to manage conflicts.
A similar approach is taken by Encap \citep{encap}: packages are
installed onto a \texttt{/usr/local/encap/packageName-packageVersion}
hierarchy, with the management of symbolic links performed by the
\texttt{epkg} script. Unlike Stow, Encap is able to revert to a previous
version of a given package thanks to the directory names used at \texttt{/usr/local/encap}. 

The popularization of union-based filesystems brought novel ideas
into package management. The GNU Hurd community proposes the use of
GNU Guix to have packages installed in their own directories. Through
the use of user \textit{profiles}, then, union-mounts provided by
Hurd's \texttt{stowfs} will create a traditional Unix directory structure
view formed from all the files in the individual package directories
listed in that profile \citep{hurd}. The Push Button Installer (PBI)
of the FreeBSD-based PC-BSD distribution used for a long time a similar
structure to GoboLinux's \texttt{/Programs}. Packages managed by PBI
were installed on \texttt{/usr/Programs} and activated by symbolic
links at \texttt{/usr/local}. The fundamental difference between the
two is that, in PBI, package dependencies (i.e. a collection of shared
objects) are shipped along with the package. For instance, the Xpdf
package ships both with the \texttt{xpdf} executable as well as with
the Xorg libraries it depends on. The storage space taken by the many
duplicated files found across different packages is managed by PBI
through a simple deduplication method based on hardlinks \citep{pbi}.
Starting with the PC-BSD 10 series, the PC-BSD project revamped their
implementation of the PBI runtime containers so that they could benefit
from a virtualized \texttt{/usr/local} namespace. At the present time
that is still an ongoing work.
\end{comment}

\begin{comment}
The desire to avoid filesystem conflicts was a key aspect in the popularization
of container technology, such as Docker \citep{Merkel2014Docker}.
Docker provides an abstraction layer so that users can deploy their
applications (together with their dependencies) inside containers
that run with isolated filesystems and other resources, as if they
were in a virtual machine. Linux kernel namespace and control groups
(cgroups) subsystems are used to implement Docker's fine-grained control
over the hardware and operating system resources. The container environment
can then contain only the necessary packages for a single application,
circumventing dependency chain conflicts that might arise from installing
multiple applications sharing a single filesystem hierarchy. These
technologies are giving birth to a new concept of package management,
as users no longer run into library versioning conflicts between the
various packages installed on their system: they simply deploy conflicting
packages as separate containers. Still, this only shifts the problem
to a larger granularity: the containers themselves need to be managed,
and various services communicating with each other in separate containers
will also have versioning compatibility requirements. More recently,
a further layer of abstraction in the form of \emph{orchestration
systems} such as Kubernetes \citep{kubernetes} has arisen to wrap
the deployment of containers, but again, package management is an
inescapable problem, and today pods of Kubernetes containers are managed
via the Helm package manager \citep{helm}, and tools such as Kustomize
\citep{kustomize} aim to provide a configuration management layer
on top of it, similar to the relationship between Puppet and a Linux
distribution package manager.
\end{comment}

\begin{comment}
\begin{itemize}
\item Short history of alternative approaches:

\begin{itemize}
\item earliest related work: GNU stow, encap. (Our paper from Workshop em
Software Livre mentions that, but we didn't really know about them
when making Gobo)
\item djb's /package structure
\item Zero Install (still active), Autopackage (dormant, ``packages must
be relocatable''), 
\end{itemize}
\item app dirs: RiscOS, Mac OSX. (Android and iOS?)
\item The Nix project has been around almost as long as GoboLinux. NixOS
is nowadays a serious contender in the world of server-oriented operating
systems.

\begin{itemize}
\item virtual machines: minimalism is making its way back in OS layout design.
(There have always been minimalistic Linux distributions, back from
the ``rescue'' distros such as Damn Small Linux and tomsrtbt (which
would fit in a floppy!).

\begin{itemize}
\item CoreOS, based on Gentoo, is the current representative of the minimalistic
server-oriented distro world.
\item Ubuntu Core was recently announced, and this might be a beginning
of a general trend of ``core'' OSes.

\begin{itemize}
\item Ubuntu Core ``snappy'' packages strongly resemble GoboLinux!
\end{itemize}
\end{itemize}
\item Homebrew, a package manager for Mac OS X, is a successful realization
of this idea. One of its original design criteria was to do package
management ``the GoboLinux way'' {[}in the git history of homebrew's
README.md we find them citing gobolinux{]} (so I guess that's the
most widespread legacy of our work)
\end{itemize}
\item What do we mean by filesystem facilities: a more powerful fs would
make things better?

\begin{itemize}
\item Back in 200x we mentioned {[}the ``clueless'' whitepaper{]} how
we needed more low-level tooling from the underlying operating system
in order to be able to realize some of the ideas of GoboLinux cleanly.
We were asking for more abstraction and isolation in userspace: essentially
we wanted union filesystems and possibly some sort of containers for
finer-grained isolation. Lacking those, we had to make do with chroot.
\item For a while we hoped that as underlying technology matured, these
ideas could come to fruition.
\item Docker seems to be proof of that; a container-based system that greatly
simplified application deployment.
\item However, Glauber Costa, one of the developers of the Linux Containers
system, described the limitations of that approach exposed the hackery
involved {[}did he write about it somewhere?{]}. Costa himself moved
away from containers and joined the efforts of the OSv project, a
minimalistic operating system targeting hypervisor-based architectures.
\end{itemize}
\end{itemize}
\end{comment}


\section{Language-specific vs. language-agnostic package managers}

\begin{figure*}[t]
\begin{centering}
{\footnotesize{}}%
\begin{tabular}{|c|>{\centering}p{0.15\paperwidth}|>{\centering}p{0.15\paperwidth}|>{\centering}p{0.15\paperwidth}|>{\centering}p{0.15\paperwidth}|}
\cline{2-5} \cline{3-5} \cline{4-5} \cline{5-5} 
\multicolumn{1}{c|}{} & \multicolumn{4}{c|}{{\footnotesize{}Language-specific managers}}\tabularnewline
\hline 
{\footnotesize{}Package managers} & \textbf{\footnotesize{}npm} & \textbf{\footnotesize{}RubyGems} & \textbf{\footnotesize{}NuGet} & \textbf{\footnotesize{}LuaRocks}\tabularnewline
\hline 
\hline 
{\footnotesize{}Portability} & \multicolumn{4}{c|}{{\footnotesize{}OS-independent (all Unix, Windows)}}\tabularnewline
\hline 
{\footnotesize{}Installs code written in} & {\footnotesize{}JS family, C/C++} & {\footnotesize{}Ruby, C/C++, JVM family} & {\footnotesize{}any .NET, C++} & {\footnotesize{}Lua family, C/C++}\tabularnewline
\hline 
{\footnotesize{}Files managed} & {\footnotesize{}JS scripts, JS modules} & {\footnotesize{}Ruby scripts, Ruby modules} & {\footnotesize{}.NET and native packages} & {\footnotesize{}Lua scripts, Lua modules}\tabularnewline
\hline 
{\footnotesize{}Supports per-user install} & \multicolumn{4}{c|}{{\footnotesize{}yes}}\tabularnewline
\hline 
\multicolumn{1}{c}{} & \multicolumn{1}{>{\centering}p{0.15\paperwidth}}{} & \multicolumn{1}{>{\centering}p{0.15\paperwidth}}{} & \multicolumn{1}{>{\centering}p{0.15\paperwidth}}{} & \multicolumn{1}{>{\centering}p{0.15\paperwidth}}{}\tabularnewline
\end{tabular}{\footnotesize\par}
\par\end{centering}
\begin{centering}
{\footnotesize{}}%
\begin{tabular}{|c|>{\centering}p{0.1\paperwidth}|>{\centering}p{0.1\paperwidth}|>{\centering}p{0.1\paperwidth}|>{\centering}p{0.1\paperwidth}|}
\cline{2-5} \cline{3-5} \cline{4-5} \cline{5-5} 
\multicolumn{1}{c|}{} & \multicolumn{4}{c|}{{\footnotesize{}Language-agnostic managers}}\tabularnewline
\hline 
{\footnotesize{}Package managers} & \textbf{\footnotesize{}Nix} & \textbf{\footnotesize{}Homebrew} & \textbf{\footnotesize{}RPM} & \textbf{\footnotesize{}GoboLinux}\tabularnewline
\hline 
\hline 
{\footnotesize{}Portability} & {\footnotesize{}Linux/macOS} & {\footnotesize{}macOS/Linux} & {\footnotesize{}Linux/AIX} & {\footnotesize{}Linux/Cygwin/OSX}\tabularnewline
\hline 
{\footnotesize{}Installs code written in} & \multicolumn{4}{c|}{{\footnotesize{}any language}}\tabularnewline
\hline 
{\footnotesize{}Files managed} & \multicolumn{4}{c|}{{\footnotesize{}all kinds}}\tabularnewline
\hline 
{\footnotesize{}Supports per-user install} & {\footnotesize{}yes} & {\footnotesize{}no{*}} & {\footnotesize{}no} & {\footnotesize{}yes}\tabularnewline
\hline 
\multicolumn{5}{l}{{\footnotesize{}{*} different installation prefixes are supported
but }\texttt{\footnotesize{}/usr/local}{\footnotesize{} is strongly
recommended.}}\tabularnewline
\end{tabular}{\footnotesize\par}
\par\end{centering}
\caption{\label{fig:langspec-vs-langagn}Contrasting language-specific and
language-agnostic package managers}
\end{figure*}

In the world of programming languages, there is a distinction between
DSLs and general purpose languages. Categorizing languages in one
camp or another is not always easy, but a working definition is that
domain-specific languages are those designed with a specific application
domain in mind, and general purpose languages are the complementary
set, that is, those languages designed not with a particular domain
in mind, but rather focusing on general areas such as ``systems programming''.

While we tend to see DSLs as smaller languages than their general-purpose
counterparts (and in fact early literature used to term them ``little
languages'' \citep{Bentley:1986:PPL:6424.315691}), what defines
a language as being a DSL is the \emph{inclusion} of features tailored
for a domain. This means that a domain-specific language may end up
including all features normally understood as those defining a general
purpose language. MATLAB \citep{matlab}, for instance, is a complete
programming language, but its wealth of features for numerical computing
it is often regarded as being domain-specific \citep{Gill:2014:DLC:2611429.2617811,Fowler2005LanguageWorkbench}.

In the world of package management, there is also a distinction between
domain-specific and general purpose systems, but it is better defined.
Language-specific managers are designed to be used in a particular
\emph{language ecosystem}. This ecosystem usually focuses around a
single language (hence the name ``language-specific''), but that
is not necessarily the case: environments such as .NET and the JVM
make this evident, but other languages also grow into families: for
example, npm supports JavaScript, CoffeeScript, TypeScript and others.
Besides, these VM-based ecosystems usually support loading native
extensions, and therefore they must also support building and integrating
libraries usually written in C or C++ (or, in the case of RubyGems
with JRuby, Java). A language-specific package manager, therefore,
is almost never specific to code written in a single language. Like
domain-specific programming languages which are not necessarily much
smaller than their general-purpose counterparts, the more sophisticated
language-specific package managers are in effect much broader package
managers with specific support for an ecosystem added. They need to
build and deploy executables, native libraries and resource files
written in different languages, keep track of installed files, check
dependencies, perform network operations and manage remote repositories.
Some of these tasks can be simplified due to ecosystem-specific assumptions,
but many are equivalent in complexity to the tasks of a system-wide
package manager.

This leads us to question why should we have language-specific managers
at all, if they replicate so much of the work done by general-purpose
package managers. Two arguments in defense of language-specific managers
are scalability and portability. If we compare the number of packages
provided by a typical Linux distribution versus the number of modules
available in mature module repositories from scripting languages,
it becomes clear that the approach of converting everything into native
packages is untenable: for example, while the repository for the Debian
Linux distribution features over 59,000 packages in total, the Maven
Central repository for Java alone contains over 290,000 packages,
with the advantage that the repository is portable to various platforms,
some of which lack a built-in universal package manager (Microsoft
Windows being a notable case). Still, this kind of effort duplication
does happen: the Debian repository contains 1,196 Ruby packages; this
is a far cry from the over 150,000 modules in the RubyGems repository.

Figure \ref{fig:langspec-vs-langagn} contrasts language-specific
and language-agnostic package managers, through a few examples. Language-specific
package managers tend to be highly portable, even if the modules in
their repositories are not. For example, while most packages for NuGet
are Windows-specific, the manager itself has been ported to Unix systems
via Mono; packages that do not depend on Windows APIs can be shared
by various platforms. Language-agnostic managers are generally system-specific,
and may present some degree of portability to other similar OSes.
Note that the extent of portability of all language-agnostic managers
in Figure \ref{fig:langspec-vs-langagn} is limited to specific Unix
variants. Those managers support packaging programs written in any
language and for that reason do not expect particular file formats
or subdirectory layouts. Language-specific managers make more assumptions
in that regard, and also support customizing the installation directory
prefix, which is a necessity for running as a non-privileged user.
Some system-wide managers, like Nix and GoboLinux support per-user
installations, but that often requires patching packages for removing
hardcoded pathnames. Homebrew supports this feature as a tool, but
their packages are not adapted for that, so per-user installations
are discouraged.

\section{Integration between languages vs. integration between package managers}

Programming languages, both general-purpose and domain-specific, frequently
have points of integration between each other, in the form of foreign
function interfaces (FFIs). Code written in one language can frequently
call into code written in another language, sometimes with some adapter
code in between. Domain-specific languages are in fact frequently
embedded in general-purpose languages and in programs. Programming
languages can also integrate between each other through common calling
and linking conventions.

The same is not true of general-purpose and domain-specific package
managers. Integration between two package managers is almost unheard
of, even when they may be found on the same system. Instead, a subset
of packages distributed through a domain-specific package manager
are repackaged in the format of the general-purpose system. These
packages are fully integrated with the broader system and fully detached
from the domain-specific manager. Packages that were not repackaged
are still available by using the domain-specific system, but others
are available twice, potentially in different versions and with different
configurations. Debian experimented with a \texttt{rubygems-integration}
package that provided a limited connection between APT and RubyGems,
allowing Debian packages of individual RubyGems to satisfy dependencies
in the gem tool, but encountered nontrivial complications in doing
so~\citep{debian-ruby-trouble,debian-ruby-packaging}. Debian has
not yet pursued even this level of integration for other widely-used
domain-specific package managers, and the integration it has for RubyGems
is ad-hoc and highly specialized. In Section~\ref{subsec:GoboLinux-Aliens}
we discuss our attempt at deeper integration in GoboLinux, but we
are aware of no other such integrations beyond what Debian performs.

A weaker form of one-way integration between package managers occurs
when the system-wide manager uses the language-specific package manager
merely as a build system. An example is the use of LuaRocks by Buildroot
\citep{buildroot}. Buildroot is a system for compiling full-system
images for embedded environments, which has its own package specification
format. It uses LuaRocks as a build tool: the Buildroot specification
scripts launch LuaRocks to generate Lua modules and then collect and
integrate them to the system.

\section{Experiences with package management}

In the following section, we share some of our experiences, each case
study dealing with one the three aspects of package management design
outlined above.

\subsection{GoboLinux\label{subsec:GoboLinux}}

GoboLinux \citep{Muhammad2002WSL} is a Linux distribution based on
the concept of installing each package in a separate installation
prefix. Introduced in 2002, it was the first Linux distribution to
be entirely based on a filesystem-oriented approach to package management\footnote{While GoboLinux remained a research distribution with a niche community,
its design proved influential, as its filesystem-oriented approach
was used as a basis for the design of Homebrew, the most popular package
manager in macOS today, as noted in its original documentation: \url{https://github.com/Homebrew/legacy-homebrew/tree/89283db693e9380ccc2e4abc4fa0ad14b4790202}}. Each program is installed under its own versioned directory, such
as \texttt{/Programs/Bash/4.3.28} and \texttt{/Programs/GTK+/3.16.0}.
This direct mapping of the package structure to the directory layout
allows one to inspect the system using standard Unix commands. For
example, to get a list of installed packages, one only needs to issue
\texttt{ls /Programs}.

As well as the individual program trees, a tree of symbolic links
called \texttt{/System/Index} collects references to the files from
every program in the system. A single directory contains symlinks
matching the structure of the ``\texttt{lib}'' directory of every
program, paralleling the contents of \texttt{/usr/lib} in a conventional
layout. Figure \ref{fig:gobofs} illustrates this structure. In this
way only a single entry in PATH is needed to find every executable
and libraries can be loaded using the ordinary linker mechanisms without
further configuration. An additional layer of fixed symlinks provides
backwards compatibility with the conventional Filesystem Hierarchy
Standard\citep{fhs}.

\begin{comment}
Since packages become self-described through the GoboLinux filesystem
hierarchy, the distribution features its own set of system management
tools built around scripting languages. At first, these scripts automated
tasks such as the installation of new packages (simply compressed
tar archives) and their ``activation'' in the system (namely, the
creation of symbolic links to their libraries, headers, executables,
and manuals) as well as their removal (achieved by deleting their
directory and the now-broken symbolic links). Over time, these scripts
inevitably became more complex as they were integrated with other
system tools and served as the pillars for \emph{Compile}, GoboLinux's
build system.

Taking inspiration from Gentoo's Portage system (which was itself
inspired from BSD Ports) \citep{Thiruvathukal2004Gentoo}, Compile
makes use of recipes that describe how to fetch the source code of
a piece of software and the sequence of commands required to build
and install it. Because recipes are frequently hand-written, it is
essential to make them as simple as possible so that users are encouraged
to contribute to the distribution's ecosystem. The approach adopted
by Compile is to embed as much code as possible in its build systems'
backends (e.g. Autoconf, Makefile, xmkmf, CMake), allowing the majority
of recipes to be described with little more than a couple of lines.
More complex build cases can be described by extending recipes with
regular shell scripting. Compile can also enable the installation
of packages through third-party package managers. More details of
that feature are given in Section \ref{subsec:GoboLinux-Aliens}.
\end{comment}

In its original design, packages compiled for GoboLinux targeted their
versioned directory during compilation. That made them aware of the
modified filesystem structure, and often required configuration contortions
and also workarounds to handle the management of files that were designed
to be shared between packages. In a later revision, GoboLinux switched
to compilation targeting \texttt{/usr} and installation to the per-program
location. Through this structure, even though packages are organized
in self-contained directories under \texttt{/Programs}, applications
find their files through the traditional Unix hierarchy, as \texttt{/usr}
is a symbolic link to \texttt{/System/Index}. 

\begin{figure}[t]
\begin{tabular}{>{\raggedright}m{0.45\paperwidth}}
\includegraphics[scale=0.6]{gobo_systemindex}\tabularnewline
(a) The filesystem is indexed with the use of \\
directories and symbolic links.\\
\tabularnewline
\includegraphics[scale=0.6]{gobo_programs}\tabularnewline
(b) Versioned directory tree.\tabularnewline
\end{tabular}\caption{\label{fig:gobofs}GoboLinux file system hierarchy}
\end{figure}

\begin{comment}
The mostly declarative style of GoboLinux recipes proved to be a success
among users and gave us greater freedom when modifying the build process.
We made major changes to the system's directory layout between releases
014 and 015 of the distribution, and the use of high-level descriptions
and our cautious avoidance of hardcoded paths allowed us to reuse
the majority of recipes with no changes.
\end{comment}

\begin{comment}
\begin{itemize}
\item parts of the Unix FS hierarchy which assume a single directory: /usr/share/icons

\begin{itemize}
\item effect this had on share/ in Gobo

\begin{itemize}
\item having to symlink /P/Foo/x.y/share into /S/L/share
\item launching helper indexing such as gtk-update-icon-cache upon each
installation
\end{itemize}
\end{itemize}
\item discuss symlinks

\begin{itemize}
\item The ``virtualized'' Unix directories of GoboLinux avoid some compatibility
issues that affect other distributions: all executables appear at
the same time in /bin, /sbin, /usr/bin and so on.
\end{itemize}
\item the build system, the tooling for generating packages, is the central
piece of a package management system.

\begin{itemize}
\item not clear at first, but looking at package management systems they
all integrate the build process. Why?
\end{itemize}
\item Discuss the challenges of GoboLinux through the prism of its build
system (?)

\begin{itemize}
\item Tried to make it easy for users to build packages.
\item Took inspiration from systems such as Gentoo, which was itself inspired
from BSD Ports.
\item aim was to make the simple cases super-simple (like a 3-line script)
and the complex cases possible (leveraging the generality of shell
scripts)
\item This worked up to a point. Eventually, started requiring more and
more metadata, even for the so-called simple cases.
\item Further, this metadata had to be integrated with the deployed system.
\item The ArchLinux build system seems to be a modern-day successor of this
style of build system in the Linux space.
\end{itemize}
\item tie in with the discussion of above section about includes? Gobo
pre-/S/I didn't need versioned includes when applications detect the
install prefix of libraries they depended on (e.g. via pkgconfig);
with /S/I, pkgconfig will return includedir as /usr/include, so this
becomes an issue: the recipe needs to point the conflicting program
to /P/Foo/x.y/include, or the user needs to temporarily symlink the
desired version (which is more fragile).

\begin{itemize}
\item Still, the compatibility gains for maintenance greatly outweigh the
losses, of course.
\end{itemize}
\end{itemize}
\end{comment}


\subsection{LuaRocks}

LuaRocks \citep{Muhammad2013LuaRocks} is a package manager for the
Lua ecosystem. It was developed building on our previous experience
writing package management tools for GoboLinux and adapting it to
the realities of a language-specific manager.

\begin{comment}
The package specification format (\emph{rockspec}) was largely influenced
by GoboLinux, and LuaRocks pushes the use of declarative specifications
even further. While the \texttt{.rockspec} files themselves are actually
Lua scripts, LuaRocks loads them using a restricted execution environment
that disables the Lua standard libraries; they essentially consist
of variable declarations, describing the package via Lua tables (Lua's
single data structure, which combines numeric and associative arrays)
\end{comment}

\begin{comment}
Another design feature inherited from GoboLinux was the support for
multiple build back-ends. In most language ecosystems, at any point
in time a single build tool is well-established as a standard (such
as \texttt{easy\_install} and later \texttt{pip} for Python, Rake
for Ruby, ExtUtils::MakeMaker and later Module::Build for Perl). In
the Lua world, by the time LuaRocks was conceived, in spite of several
contenders, there was no clear winner as a standard build tool. To
deal with the variety of build systems, OS-level package managers
typically let developers call their preferred build tools explicitly
in imperative scripts. LuaRocks attempted to solve this in a more
controlled manner, with a system of plugins for the various tools,
akin to the one used in GoboLinux. In LuaRocks, each plugin is implemented
as a Lua module, selected through an entry in the \emph{rockspec}. For example,
using \texttt{build.type=\textquotedbl cmake\textquotedbl} causes
LuaRocks to invoke CMake with the appropriate arguments. We also included
a simple built-in build system, invoked via \texttt{build.type=\textquotedbl builtin\textquotedbl},
which is able to install Lua files and portably compile C code into
Lua modules. This proved a success among developers: at the time of
this writing, 75\% of all packages in the LuaRocks repository use
the built-in build system.

LuaRocks installs all packages into a sandbox directory and later
moves them to their final destinations. The actual installation prefix
is never told to the build system under execution. This prevents a
package from hardcoding its own installation directory in its source
code. While the ability to do this is a feature sometimes requested
by developers (as it would make it easier to load asset files, for
example), disallowing hardcoded paths ensures that every package built
is relocatable. Having fully relocatable packages is rare on Unix,
but is an expected feature on Windows. Having to cater to such conflicting
requirements is a constant in writing portable software; to alleviate
the issue of finding asset files, one of the authors developed a Lua
module called \texttt{datafile} \footnote{\url{http://github.com/hishamhm/datafile}, also available via \texttt{luarocks
install datafile}}, which resolves directory locations portably at run-time.
\end{comment}

The design changes that LuaRocks underwent were due to lessons learned
on the specificities of language-specific package management. The
original design of LuaRocks was filesystem-oriented, like GoboLinux.
LuaRocks included then a custom wrapper for Lua's \texttt{require()}
function, much like RubyGems. However, many Lua users perceived the
wrapper as tampering with a standard library function, and disliked
having to perform an initial setup in their scripts for using modules
installed via LuaRocks \footnote{Since Ruby 1.9, the interpreter preloads the \texttt{rubygems} module
automatically; in prior versions uses had to add \texttt{require 'rubygems'}
explicitly. This was never an option for Lua due to the language's
minimalistic design, rendering LuaRocks as a strictly optional component.}. For LuaRocks 2.0, the design was changed to be database-oriented,
so that Lua modules could be installed into a typical Unix-like layout
that matched the default configuration of the Lua interpreter's package
loader. With all packages installed under a single directory, a database
had to be put in place matching files to packages. Supporting multiple
versions of the same package installed at the same time is still possible,
but requires the now-optional custom package loader, which produces
versioned filenames when the dependency graph requires an old version
of a module. This language-specific runtime adjustment allows avoiding
the issue with filename conflicts, so common with database-oriented
designs --- a luxury that operating system package managers cannot
afford so easily.

Having a high-level declarative specification allowed us to make such
radical changes to the installation layout easily. Since LuaRocks
produces relocatable packages, it does not provide to specification
files (\emph{rockspecs}) any knowledge of the final directory structure.
This allowed all existing \emph{rockspecs} to be used in the new directory
layout without any changes. This level of information hiding was only
possible because we were dealing with a language-specific manager,
where we knew what was in the files (Lua source code and binary dynamic
libraries) and how they would be used (as command-line scripts or
loaded by Lua through its package loader system).

\subsection{GoboLinux Aliens\label{subsec:GoboLinux-Aliens}}

In GoboLinux we researched the idea of building a foreign function
interface (FFI) of sorts into our general-purpose package manager,
which we called Aliens\citep{Homer2010LCA}. Aliens provides an API
to write shims that connect the general-purpose system package manager
with domain-specific package managers.

With Aliens, packages in the general-purpose manager may express a
dependency on a package provided by a supported domain-specific manager:
for example, a package that requires the Perl \texttt{XML::Parser}
module, available from CPAN, can express a dependency ``\texttt{CPAN:XML::Parser
>= 2.34}''. The Aliens system directs such a dependency to a translating
shim, which uses the CPAN tool to confirm whether it is satisfied,
to install the package (and its dependencies) if required, and to
upgrade it, communicating any necessary information back to the general-purpose
manager. The shim can then make symbolic links for any binaries or
native libraries that have been installed. Any package in one of the
supported domain-specific managers is automatically available in this
way, without creating wrapper packages.

The domain-specific managers themselves are not modified in this process.
Each system is given complete control of a directory tree, and the
relevant languages configured to search in that tree. This protects
against changes in the functioning of the third-party systems, and
allows users to access them directly as well. A drawback, however,
is that the domain-specific managers do not have reciprocal access
to the wider system: installing a RubyGem that depends on a native
library will not innately result in the native dependency being satisfied.
The cross-platform nature of these systems makes even specifying such
information in a machine-readable way difficult, although some, notably
LuaRocks, make the attempt.

Not all domain-specific package managers lend themselves to this integration.
Some are resistant to placing their files within a restricted directory
tree, preferring to install into the global filesystem hierarchy where
they may interfere with each other and the system, while others do
not mechanize well. This limited coverage is an additional drawback
of the Aliens approach, but one that is limited to failing to solve
an existing problem, rather than creating a new one. As with programming
languages, a consensus implementation platform would inevitably be
simpler, but social and technical factors make it impractical. FFIs,
and Aliens, attempt to bridge the gap, with reasonable success.

\vspace{-0.3em}


\section{Conclusion}

\begin{comment}
In this paper, we presented our practical experiences in the development
and maintenance of a system-wide package manager for a Linux distribution
and a portable package manager for a scripting language, and an analysis
of the landscape of existing methodologies for package management. 
\end{comment}
Package management is an area that is notably neglected in academic
studies, but is one of practical impact in the design of modern operating
systems and module systems for programming languages. In the realm
of programming languages, we have useful ways to categorize languages.
Package management even lacks common terminology, and each new system
faces the same design issues time and again, even as we move to containers
and orchestration systems \citep{helm}.

As we categorize package management systems, we conclude that filesystem-oriented
designs are preferable as they tend to be less susceptible to conflicts,
but they require some level of intervention to enable files to be
found at run time. We observe that this control exists when language-specific
package managers are bundled with the language environment, as is
the case with npm for node.js and RubyGems for Ruby. These managers
were free to adopt filesystem-oriented designs since they adjusted
their module loaders accordingly. The other way to exert this control
over run-time lookup is to employ a system-wide lower-level solution
as we did in GoboLinux with the \texttt{/System/Index} tree of symbolic
links or in the stowfs filesystem virtualization proposed for GNU
Hurd \citep{stow}. Database-oriented designs, on the other hand,
are more generally applicable, but are more opaque to their users
and are more prone to package conflict and file-to-package synchronization
issues. For these reasons, we advocate filesystem-oriented systems
in general, but we also recognize that there are situations where
a database-oriented solution works best to preserve compatibility
with the ecosystem at play, as was the case with LuaRocks.

Our classification of package managers as language-ag\-nos\-tic and language-specific
highlighted the complementary qualities of these two classes of managers.
The existence of language-specific package managers distributes integration
efforts, as upstream module developers are often the package integrators
themselves. This allows scaling repositories way beyond what is possible
through the work of OS distribution maintainers, but also generates
some tension between the language and distribution communities as
perceived duplicate work and incompatibilites happen. Through our
experience in both ends of the spectrum of package management ---
from low-level distribution management in GoboLinux to high-level
language modules in LuaRocks --- we observed a necessity for these
different levels of system organization to recognize each other and
aim for cooperation. Package managers do not exist on their own, but
are part of an ecosystem in which other package managers often take
part. We shared our experience in progressing on this direction with
the GoboLinux Aliens project, and we plan to further pursue FFI-style
package management interoperability.

\renewcommand{\refname}{REFERENCES}

\bibliographystyle{wileyj}
\bibliography{gobo}

\end{document}
