#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass acmart
\begin_preamble
\acmConference{PLOS 2019}{October 29, 2019}{Huntsville, Canada}
\acmMonth{10}
\acmYear{2019}
\copyrightyear{2019}
\setcopyright{acmlicensed}
\settopmatter{printacmref=false}
\end_preamble
\options format=sigplan,10pt
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style \use_bibtopic false
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Understanding package management
\end_layout

\end_inset

Understanding package management
\begin_inset Newline newline
\end_inset

through the lens of programming languages
\end_layout

\begin_layout Author
Hisham Muhammad
\end_layout

\begin_layout Affiliation
Kong Inc.
\end_layout

\begin_layout Email
hisham@konghq.com
\end_layout

\begin_layout Author
Lucas C.
 Villa Real
\end_layout

\begin_layout Affiliation
IBM Research - Sao Paulo, Brazil
\end_layout

\begin_layout Email
lucasvr@br.ibm.com
\end_layout

\begin_layout Author
Michael Homer
\end_layout

\begin_layout Affiliation
Victoria University of Wellington - Wellington, New Zealand
\end_layout

\begin_layout Email
mwh@ecs.vuw.ac.nz
\end_layout

\begin_layout Abstract
Package management is instrumental for programming languages and operating
 systems, and yet it is neglected by both areas as an implementation detail.
 For this reason, it lacks the same kind of conceptual organization: we
 lack terminology to classify them or to reason about their design trade-offs.
 In this paper, we share our experience both OS and language-specific package
 manager development, categorizing families of package managers and discussing
 their design implications beyond particular implementations.
 We also identify possibilities in the still largely unexplored area of
 package manager interoperability.
\end_layout

\begin_layout Keywords
\noindent
package management, operating systems, module systems, filesystem hierarchy
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Package management is an area that lies somewhere in the border between
 programming languages and operating systems: packaging is a step that sits
 after a language's build process, and before an operating system's component
 installation.
 For this reason, it seems to be overlooked by both fields as an implementation
 issue.
 In the meantime, package management keeps growing in complexity.
 New languages, new deployment models and new portability requirements,
 all give rise to new package management systems.
 Further, this is not simply a matter of competing implementations: modern
 complex environments often require several package managers to be used
 in tandem.
\end_layout

\begin_layout Standard
For example, when writing JavaScript web applications on a Mac environment,
 a developer may require using Bower 
\begin_inset CommandInset citation
LatexCommand cite
key "bower"
literal "true"

\end_inset

, a package manager for client-side JavaScript components.
 Bower is installed using 
\family typewriter
npm
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "npm"
literal "true"

\end_inset

, a package manager for 
\family typewriter
node.js
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "nodejs"
literal "true"

\end_inset

, a JavaScript environment.
 On a Mac system, the typical way to install command-line tools such as
 
\family typewriter
npm
\family default
 is via either Homebrew 
\begin_inset CommandInset citation
LatexCommand cite
key "homebrew"
literal "true"

\end_inset

 or MacPorts 
\begin_inset CommandInset citation
LatexCommand cite
key "macports"
literal "true"

\end_inset

, the two most popular general-purpose package managers for macOS.
 This is not a deliberately contrived example; it is the regular way to
 install development modules for a popular language in a modern platform.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Burns2012Deploying"
literal "true"

\end_inset

 we have another example of a typical software stack, where a deployment
 and management scenario for Ruby on Rails applications is described combining
 a number of tools.
 It uses Vagrant 
\begin_inset CommandInset citation
LatexCommand cite
key "Hashimoto2013Vagrant"
literal "true"

\end_inset

 for virtual machine management; Puppet 
\begin_inset CommandInset citation
LatexCommand cite
key "Arrundel2011Puppet"
literal "true"

\end_inset

 for editing system configuration files and driving the system-wide package
 manager on servers; Capistrano for deploying the Ruby on Rails application,
 including installing Ruby scripts and migrating database tables, driving
 RubyGems, the language-specific package manager for Ruby modules (with
 Bundler to mitigate module version conflicts); and RVM for managing conflicting
 versions of Ruby itself.
 It is interesting to note the number of different tools being used on top
 of each other to manage containment and compatibility issues on various
 layers; and again, this is a typical, realistic scenario.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The combinations of package managers change as we move to a different operating
 system or use a different language.
 Learning one's way through a new language or system, nowadays, includes
 learning one or more packaging environments.
 As a developer of modules, this includes not only using package managers
 but also learning to deploy code using them, which includes syntaxes for
 package specification formats, dependency and versioning rules and deployment
 conventions.
 Simply ignoring these environments and managing modules and dependencies
 by hand is tempting, but the complexity of heterogeneous environments and
 keeping track of dependency updates can become burdensome â€” all these package
 managers were created to solve practical problems which the developer would
 have to otherwise directly handle, after all.
 Another alternative that is often proposed, especially by users of operating
 systems that feature a system-provided package manager (as is the case
 of most Linux distributions), is to avoid using multiple package managers
 and use a single general-purpose package manager.
 This is, of course, as much as a solution as trying to make everyone agree
 on a single programming language, and this is the first of various analogies
 between package management and programming languages that we will make
 throughout this paper.
 The result is that the ecosystem is not getting any simpler, and at first
 glance it seems that package management is indeed a largely unsolved problem.
\end_layout

\begin_layout Standard
However, maybe the statement 
\begin_inset Quotes eld
\end_inset

package management is an unsolved problem
\begin_inset Quotes erd
\end_inset

 simply does not make sense, and is akin to saying that 
\begin_inset Quotes eld
\end_inset

programming languages are an unsolved problem
\begin_inset Quotes erd
\end_inset

.
 In the programming languages world we accept that the multitude of languages
 is a given.
 Beyond that, we understand that there are families of languages with different
 paradigms, with well-known tradeoffs.
 We also accept that there is room for domain-specific languages (DSLs)
 and for general-purpose languages.
 Most importantly, we know how to set boundaries for each language and how
 to make DSLs and general-purpose languages interact.
 Most existing package management systems, however, are still oblivious
 to the fact that they exist as part of a larger ecosystem, with parts of
 it handled by other package managers.
\end_layout

\begin_layout Standard
In this paper we draw on our own unique combination of experiences on all
 sides of this topic: developing a system-wide package manager for a Linux
 distribution 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2002WSL,Homer2010LCA"
literal "true"

\end_inset

, creating a language-specific package manager 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"
literal "true"

\end_inset

, and integrating system and language-specific package managers 
\begin_inset CommandInset citation
LatexCommand cite
key "Homer2010LCA"
literal "true"

\end_inset

, as well as being simply developers and end users of other software.
 By building a taxonomy for package management and sharing our experiences
 with package management development in both the programming language and
 operating system spaces, we aim in this paper to make the case that not
 only the problem space of package management mirrors that of programming
 languages, it should follow the lead of programming languages in the solution
 space as well.
\end_layout

\begin_layout Standard
\begin_inset VSpace -0.2em
\end_inset


\end_layout

\begin_layout Section
Paradigms of package management: filesystem-oriented vs.
 database-oriented
\end_layout

\begin_layout Standard
It is a typical didactic device to organize the landscape of programming
 languages into paradigms, such as imperative, functional, object-oriented,
 and so on.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
These paradigms describe the core conceptual frameworks on top of which
 languages are designed.
 
\end_layout

\end_inset

The paradigms a language is categorized into inform users about particular
 design choices, and with these choices come design trade-offs.
 In the world of package managers, we can also identify general paradigms,
 by looking at their core concepts and design trade-offs.
 Package managers are programs that map relations between files and packages
 (which correspond to sets of files), and between packages (dependencies),
 allowing users to perform maintenance of their systems in terms of packages
 rather than at the level of individual files.
 The central design choice in a package manager, therefore, is how to perform
 those mappings.
\end_layout

\begin_layout Standard
There are two approaches on how to map files to packages: the mapping can
 be either 
\emph on
internal
\emph default
 or 
\emph on
external
\emph default
 to the hierarchical structure of directories where the files reside.
 As this choice embodies a series of trade-offs and is the single decision
 that affects the design and implementation of a package manager the most,
 we identify these as two paradigms of package management.
 When the mapping is done within the file hierarchy structure, we say that
 package management is 
\emph on
filesystem-oriented
\emph default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Being database-oriented does not imply an opaque, binary database format.
 Various database-oriented package managers store their file manifests in
 plain text files
\end_layout

\end_inset

.
 When it is external to the hierarchy of files being managed, the mapping
 needs to be stored elsewhere.
 We say in these cases that management is 
\emph on
database-oriented
\emph default
.
 Most package managers for Linux distributions, such as RPM and dpkg/APT,
 are database-oriented.
 Filesystem-oriented package management is more often seen in language-specific
 package managers, but as we will see in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GoboLinux"

\end_inset

, it can also be performed system-wide.
\end_layout

\begin_layout Standard
The directory structure used by 
\family typewriter
pip
\family default
, the package manager for Python modules, is representative of the database-orie
nted style.
 Note that all installed modules are stored under 
\family typewriter
/usr/lib/python3.7/site-packages/: 
\family default
this structure was already the default subdirectory for locally-installed
 modules prior to the introduction of 
\family typewriter
pip
\family default
.
 Database-oriented designs are often chosen when the package manager needs
 to accomodate a pre-existing directory structure.
 If Python packages have modules with the same name, clashes may occur.
 In a filesystem-oriented design, such as for example that of RubyGems,
 this problem would not happen.
 Each package has its own subtree under a versioned directory, and the 
\family typewriter
rubygems.rb
\family default
 module, part of the default installation of Ruby, takes care of finding
 the appropriate files when modules are loaded with the 
\family typewriter
require
\family default
 function.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pm-taxonomy"

\end_inset

 lists more examples of package managers and their classification.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not sure at what point this paragraph should fit.
\end_layout

\end_inset

Initially it may seem that this is an implementation detail, and that this
 distinction is, or should be, transparent to users of package managers.
 As long as they can type a command to install a package and then launch
 the program or load the library, how the manager keeps its consistency
 is irrelevant.
 While this is true for end-users installing packages and using applications
 and libraries, it is not true for another category of users of package
 managers: those who do the packaging of programs.
 In other words, this is akin to saying that on one hand end-users of applicatio
ns shouldn't care what language they are written in, but on the other hand
 the language paradigm affects those who write programs greatly.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The major trade-off between the filesystem-oriented and the database-oriented
 approaches is whether applications should be aware of the file structure
 defined by the manager or whether the manager should adapt to the file
 structure defined by applications.
 This affects how the manager tracks the mapping of files and how applications
 are configured to find their resource files.
 
\end_layout

\begin_layout Standard
In filesystem-oriented managers the mapping of files to packages is simple.
 File conflicts are naturally avoided by storing files of different packages
 in separate subtrees.
 Versioning conflicts between variants of the same package can also be handled
 via the tree structure.
 The structure also becomes more transparent to users, which can simplify
 their experience.
 The run-time lookup of files by applications, however, can be complicated,
 if they are oblivious to the structure defined by the package manager.
 Applications must either agree beforehand to this structure (which might
 be an option in domain-specific environments), or the package manager has
 to do extra work to configure them to use the structure; in the worst case,
 patching them.
\end_layout

\begin_layout Standard
Conversely, in database-oriented managers the mapping of files to packages
 is more complicated.
 Applications may install files wherever they please, and the package manager
 needs to keep track.
 This includes handling potential conflicts if two packages want to use
 the same pathname.
 Database-oriented systems will usually report on these conflicts and forbid
 them.
 It is up to the integrator (such as a distribution developer) who is building
 packages to resolve the conflict somehow.
 Also, the package manager needs to verify that the database and the contents
 of the filesystem remain in sync, which is trivial in the filesystem-oriented
 approach.
 The run-time lookup of files on database-oriented systems, on its turn,
 is greatly simplified.
 In most cases it will be a non-issue, since each file is in the location
 the application expected it to be in the first place.
 However, it does become an issue when the file has been relocated by the
 integrator who built the package, perhaps for solving conflicts.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Challenges with database-oriented systems
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Repository maintainers of database-oriented package managers often solve
 versioning conflicts by resorting to filesystem-oriented approaches.
 For example, the maintainer of Debian packages for the Lua virtual machine
 patches its Makefile to install C headers under versioned directories such
 as 
\family typewriter
/usr/include/lua5.3
\family default
, to avoid conflicts of simultaneous Lua versions in the system installing
 
\family typewriter
lua.h
\family default
.
 Such changes propagate to users of these packages: Lua-based software such
 as LuaRocks 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"
literal "true"

\end_inset

 and Prosody 
\begin_inset CommandInset citation
LatexCommand cite
key "prosody"
literal "true"

\end_inset

 include code in their installation scripts specifically to handle Debian
 locations.
 Meanwhile, FreeBSD uses 
\family typewriter
/usr/include/lua53
\family default
 and NetBSD uses 
\family typewriter
/usr/include/lua-5.3
\family default
.
 To reduce this kind of incompatibility among downstream distributors, many
 upstream maintainers adopt hierarchical versioning structures themselves:
 C headers for Python, for example, install into versioned directories such
 as 
\family typewriter
/usr/include/python3.7
\family default
 by default in every system.
 It is unclear, however, which packages are the ones where users will desire
 to keep simultaneously installed versions and which are not; one might
 ask why 
\emph on
all
\emph default
 C headers aren't installed in a versioned way.
 In fact, when we look at Unix shared libraries, we see that this is the
 case: the standard practice is to install libraries in versioned files
 such as 
\family typewriter
libfoo.so.1
\family default
, with a 
\family typewriter
libfoo.so
\family default
 symbolic link for user convenience.
 Note that, as typical of filesystem-oriented approaches, there needs to
 be some cooperation for run-time lookup, and indeed the dynamic linker
 is aware of this structure and makes use of versioned filenames.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Challenges with filesystem-oriented systems
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Filesystem-oriented managers also present their own set of challenges, as
 the description of packages as set of files does not present a full picture.
 Packages, especially in system-wide installations, often need to perform
 global changes to the system, such as adding users and setting environment
 variables.
 Some applications also include database-oriented portions which are assumed
 to be updated by installation scripts, such as refreshing global caches.
 Non-relocatable packages often assume hardcoded default paths in which
 resource files are expected to be found; if the package manager employs
 a different organization, it needs to reconfigure applications to make
 sure the required files are found.
 One common solution is to use environment variables, since applications
 often support setting custom paths via variables in addition to the system-wide
 defaults.
 Most applications can be installed in custom locations, with the installation
 prefix being adjustable at compile time.
 The 
\family typewriter
/opt
\family default
 directory is a traditional location for filesystem-oriented organization
 of additional packages.
 Core system services are often harder to relocate.
\end_layout

\begin_layout Standard
To use the filesystem or a database is a frequent design dilemma beyond
 package management, especially on Unix systems, where 
\begin_inset Quotes eld
\end_inset

everything is a file
\begin_inset Quotes erd
\end_inset

 is a long-standing tradition.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Different styles of bootscripts on Unix employ one or the other approach,
 with System V being the archetypical file-hierarchy-based init system and
 BSD init using 
\family typewriter
/etc/rc.conf
\family default
 as a central configuration file.
 Program configuration can either use on separate text-based configuration
 files under 
\family typewriter
/etc
\family default
 or a central registry of settings, such as GConf 
\begin_inset CommandInset citation
LatexCommand cite
key "Pennington2002GConf"
literal "true"

\end_inset

.
 In modern Linux distributions, the package manager is the most central
 component for organizing the operating system.
 
\end_layout

\end_inset

Database-oriented solutions often are considered un-Unix-like (GConf, for
 instance, raises comparisons to the Windows Registry 
\begin_inset CommandInset citation
LatexCommand cite
key "Wallen2003GConfWin"
literal "true"

\end_inset

).
 It is remarkable that, in spite of the Unix philosophy, most Linux package
 managers are primarily database-oriented.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Filesystem-oriented
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Database-oriented
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-agnostic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Homebrew (macOS), GNU Stow, Nix,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Encap, PBI 8 (PC-BSD), GoboLinux
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
RPM (RedHat/Fedora/etc.), dpkg/apt (Debian/Ubuntu/etc.)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
PBI 9 (PC-BSD), Pacman (ArchLinux)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-specific
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
npm (server-side JavaScript), Bower (client-side JavaScript)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
RubyGems (Ruby), Cargo (Rust), LuaRocks 1.x (Lua)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Cabal (Haskell), pip (Python), LuaRocks 2.x (Lua)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pm-taxonomy"

\end_inset

A package manager taxonomy, with representative examples
\begin_inset Note Note
status open

\begin_layout Plain Layout
More db examples??
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout

\series bold
Other filesystem-based approaches
\end_layout

\begin_layout Plain Layout
One of the earliest filesystem-oriented package managers to note is GNU
 Stow 
\begin_inset CommandInset citation
LatexCommand cite
key "stow"
literal "true"

\end_inset

, which inherited ideas from Carnegie Mellon's Depot 
\begin_inset CommandInset citation
LatexCommand cite
key "Colyer1992Depot"
literal "true"

\end_inset

.
 Stow focuses on the management of programs installed on non-regular paths
 (e.g.
 on some user's home directory, on external devices, etc).
 Given the path to one such program tree, Stow 
\begin_inset Quotes eld
\end_inset

activates
\begin_inset Quotes erd
\end_inset

 it on the system by creating symbolic links to the program's contents at
 a central location such as 
\family typewriter
/usr/local
\family default
.
 Existing symbolic links are expanded with directories to manage conflicts.
 A similar approach is taken by Encap 
\begin_inset CommandInset citation
LatexCommand cite
key "encap"
literal "true"

\end_inset

: packages are installed onto a 
\family typewriter
/usr/local/encap/packageName-packageVersion
\family default
 hierarchy, with the management of symbolic links performed by the 
\family typewriter
epkg
\family default
 script.
 Unlike Stow, Encap is able to revert to a previous version of a given package
 thanks to the directory names used at 
\family typewriter
/usr/local/encap
\family default
.
 
\end_layout

\begin_layout Plain Layout
The popularization of union-based filesystems brought novel ideas into package
 management.
 The GNU Hurd community proposes the use of GNU Guix to have packages installed
 in their own directories.
 Through the use of user 
\shape italic
profiles
\shape default
, then, union-mounts provided by Hurd's 
\family typewriter
stowfs
\family default
 will create a traditional Unix directory structure view formed from all
 the files in the individual package directories listed in that profile
 
\begin_inset CommandInset citation
LatexCommand cite
key "hurd"
literal "true"

\end_inset

.
 The Push Button Installer (PBI) of the FreeBSD-based PC-BSD distribution
 used for a long time a similar structure to GoboLinux's 
\family typewriter
/Programs
\family default
.
 Packages managed by PBI were installed on 
\family typewriter
/usr/Programs
\family default
 and activated by symbolic links at 
\family typewriter
/usr/local
\family default
.
 The fundamental difference between the two is that, in PBI, package dependencie
s (i.e.
 a collection of shared objects) are shipped along with the package.
 For instance, the Xpdf package ships both with the 
\family typewriter
xpdf
\family default
 executable as well as with the Xorg libraries it depends on.
 The storage space taken by the many duplicated files found across different
 packages is managed by PBI through a simple deduplication method based
 on hardlinks 
\begin_inset CommandInset citation
LatexCommand cite
key "pbi"
literal "true"

\end_inset

.
 Starting with the PC-BSD 10 series, the PC-BSD project revamped their implement
ation of the PBI runtime containers so that they could benefit from a virtualize
d 
\family typewriter
/usr/local
\family default
 namespace.
 At the present time that is still an ongoing work.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
The desire to avoid filesystem conflicts was a key aspect in the popularization
 of container technology, such as Docker 
\begin_inset CommandInset citation
LatexCommand cite
key "Merkel2014Docker"
literal "true"

\end_inset

.
 Docker provides an abstraction layer so that users can deploy their application
s (together with their dependencies) inside containers that run with isolated
 filesystems and other resources, as if they were in a virtual machine.
 Linux kernel namespace and control groups (cgroups) subsystems are used
 to implement Docker's fine-grained control over the hardware and operating
 system resources.
 The container environment can then contain only the necessary packages
 for a single application, circumventing dependency chain conflicts that
 might arise from installing multiple applications sharing a single filesystem
 hierarchy.
 These technologies are giving birth to a new concept of package management,
 as users no longer run into library versioning conflicts between the various
 packages installed on their system: they simply deploy conflicting packages
 as separate containers.
 Still, this only shifts the problem to a larger granularity: the containers
 themselves need to be managed, and various services communicating with
 each other in separate containers will also have versioning compatibility
 requirements.
 More recently, a further layer of abstraction in the form of 
\emph on
orchestration systems
\emph default
 such as Kubernetes 
\begin_inset CommandInset citation
LatexCommand citep
key "kubernetes"
literal "false"

\end_inset

 has arisen to wrap the deployment of containers, but again, package management
 is an inescapable problem, and today pods of Kubernetes containers are
 managed via the Helm package manager 
\begin_inset CommandInset citation
LatexCommand citep
key "helm"
literal "false"

\end_inset

, and tools such as Kustomize 
\begin_inset CommandInset citation
LatexCommand citep
key "kustomize"
literal "false"

\end_inset

 aim to provide a configuration management layer on top of it, similar to
 the relationship between Puppet and a Linux distribution package manager.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Itemize
Short history of alternative approaches:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
earliest related work: GNU stow, encap.
 (Our paper from Workshop em Software Livre mentions that, but we didn't
 really know about them when making Gobo)
\end_layout

\begin_layout Itemize
djb's /package structure
\end_layout

\begin_layout Itemize
Zero Install (still active), Autopackage (dormant, 
\begin_inset Quotes eld
\end_inset

packages must be relocatable
\begin_inset Quotes erd
\end_inset

), 
\end_layout

\end_deeper
\begin_layout Itemize
app dirs: RiscOS, Mac OSX.
 (Android and iOS?)
\end_layout

\begin_layout Itemize
The Nix project has been around almost as long as GoboLinux.
 NixOS is nowadays a serious contender in the world of server-oriented operating
 systems.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
virtual machines: minimalism is making its way back in OS layout design.
 (There have always been minimalistic Linux distributions, back from the
 
\begin_inset Quotes eld
\end_inset

rescue
\begin_inset Quotes erd
\end_inset

 distros such as Damn Small Linux and tomsrtbt (which would fit in a floppy!).
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
CoreOS, based on Gentoo, is the current representative of the minimalistic
 server-oriented distro world.
\end_layout

\begin_layout Itemize
Ubuntu Core was recently announced, and this might be a beginning of a general
 trend of 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 OSes.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Ubuntu Core 
\begin_inset Quotes eld
\end_inset

snappy
\begin_inset Quotes erd
\end_inset

 packages strongly resemble GoboLinux!
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Homebrew, a package manager for Mac OS X, is a successful realization of
 this idea.
 One of its original design criteria was to do package management 
\begin_inset Quotes eld
\end_inset

the GoboLinux way
\begin_inset Quotes erd
\end_inset

 [in the git history of homebrew's README.md we find them citing gobolinux]
 (so I guess that's the most widespread legacy of our work)
\end_layout

\end_deeper
\begin_layout Itemize
What do we mean by filesystem facilities: a more powerful fs would make
 things better?
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Back in 200x we mentioned [the 
\begin_inset Quotes eld
\end_inset

clueless
\begin_inset Quotes erd
\end_inset

 whitepaper] how we needed more low-level tooling from the underlying operating
 system in order to be able to realize some of the ideas of GoboLinux cleanly.
 We were asking for more abstraction and isolation in userspace: essentially
 we wanted union filesystems and possibly some sort of containers for finer-grai
ned isolation.
 Lacking those, we had to make do with chroot.
\end_layout

\begin_layout Itemize
For a while we hoped that as underlying technology matured, these ideas
 could come to fruition.
\end_layout

\begin_layout Itemize
Docker seems to be proof of that; a container-based system that greatly
 simplified application deployment.
\end_layout

\begin_layout Itemize
However, Glauber Costa, one of the developers of the Linux Containers system,
 described the limitations of that approach exposed the hackery involved
 [did he write about it somewhere?].
 Costa himself moved away from containers and joined the efforts of the
 OSv project, a minimalistic operating system targeting hypervisor-based
 architectures.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Section
Language-specific vs.
 language-agnostic package managers
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide true
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="15page%">
<column alignment="center" valignment="top" width="15page%">
<column alignment="center" valignment="top" width="15page%">
<column alignment="center" valignment="top" width="15page%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-specific managers
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Package managers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
npm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
RubyGems
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
NuGet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
LuaRocks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Portability
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
OS-independent (all Unix, Windows)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Installs code written in
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JS family, C/C++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby, C/C++, JVM family
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
any .NET, C++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua family, C/C++
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Files managed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JS scripts, JS modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby scripts, Ruby modules
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
.NET and native packages
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua scripts, Lua modules
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Supports per-user install
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-agnostic managers
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Package managers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Nix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Homebrew
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
RPM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
GoboLinux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Portability
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/macOS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
macOS/Linux
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/AIX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/Cygwin/OSX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Installs code written in
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
any language
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Files managed
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
all kinds
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Supports per-user install
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
no*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
* different installation prefixes are supported but 
\family typewriter
/usr/local
\family default
 is strongly recommended.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:langspec-vs-langagn"

\end_inset

Contrasting language-specific and language-agnostic package managers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the world of programming languages, there is a distinction between DSLs
 and general purpose languages.
 Categorizing languages in one camp or another is not always easy, but a
 working definition is that domain-specific languages are those designed
 with a specific application domain in mind, and general purpose languages
 are the complementary set, that is, those languages designed not with a
 particular domain in mind, but rather focusing on general areas such as
 
\begin_inset Quotes eld
\end_inset

systems programming
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
While we tend to see DSLs as smaller languages than their general-purpose
 counterparts (and in fact early literature used to term them 
\begin_inset Quotes eld
\end_inset

little languages
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Bentley:1986:PPL:6424.315691"
literal "true"

\end_inset

), what defines a language as being a DSL is the 
\emph on
inclusion
\emph default
 of features tailored for a domain.
 This means that a domain-specific language may end up including all features
 normally understood as those defining a general purpose language.
 MATLAB 
\begin_inset CommandInset citation
LatexCommand citep
key "matlab"
literal "false"

\end_inset

, for instance, is a complete programming language, but its wealth of features
 for numerical computing it is often regarded as being domain-specific 
\begin_inset CommandInset citation
LatexCommand cite
key "Gill:2014:DLC:2611429.2617811,Fowler2005LanguageWorkbench"
literal "true"

\end_inset

.
\end_layout

\begin_layout Standard
In the world of package management, there is also a distinction between
 domain-specific and general purpose systems, but it is better defined.
 Language-specific managers are designed to be used in a particular 
\emph on
language ecosystem
\emph default
.
 This ecosystem usually focuses around a single language (hence the name
 
\begin_inset Quotes eld
\end_inset

language-specific
\begin_inset Quotes erd
\end_inset

), but that is not necessarily the case: environments such as .NET and the
 JVM make this evident, but other languages also grow into families: for
 example, npm supports JavaScript, CoffeeScript, TypeScript and others.
 Besides, these VM-based ecosystems usually support loading native extensions,
 and therefore they must also support building and integrating libraries
 usually written in C or C++ (or, in the case of RubyGems with JRuby, Java).
 A language-specific package manager, therefore, is almost never specific
 to code written in a single language.
 Like domain-specific programming languages which are not necessarily much
 smaller than their general-purpose counterparts, the more sophisticated
 language-specific package managers are in effect general package managers
 with specific support for an ecosystem added.
 They need to build and deploy executables, native libraries and resource
 files written in different languages, keep track of installed files, check
 dependencies, perform network operations and manage remote repositories.
 Some of these tasks can be simplified due to ecosystem-specific assumptions,
 but many are equivalent in complexity to the tasks of a system-wide package
 manager.
\end_layout

\begin_layout Standard
This leads us to question why should we have language-specific managers
 at all, if they replicate so much of the work done by general-purpose package
 managers.
 Two arguments in defense of language-specific managers are scalability
 and portability.
 If we compare the number of packages provided by a typical Linux distribution
 versus the number of modules available in mature module repositories from
 scripting languages, it becomes clear that the approach of converting everythin
g into native packages is untenable: for example, while the repository for
 the Debian Linux distribution features over 59,000 packages in total, the
 Maven Central repository for Java alone contains over 290,000 packages,
 with the advantage that the repository is portable to various platforms,
 some of which lack a built-in universal package manager (Microsoft Windows
 being a notable case).
 Still, this kind of effort duplication does happen: the Debian repository
 contains 1,196 Ruby packages; this is a far cry from the over 150,000 modules
 in the RubyGems repository.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:langspec-vs-langagn"

\end_inset

 contrasts language-specific and language-agnostic package managers, through
 a few examples.
 Language-specific package managers tend to be highly portable, even if
 the modules in their repositories are not.
 For example, while most packages for NuGet are Windows-specific, the manager
 itself has been ported to Unix systems via Mono; packages that do not depend
 on Windows APIs can be shared by various platforms.
 Language-agnostic managers are generally system-specific, and may present
 some degree of portability to other similar OSes.
 Note that the extent of portability of all language-agnostic managers in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:langspec-vs-langagn"

\end_inset

 is limited to specific Unix variants.
 Those managers support packaging programs written in any language and for
 that reason do not expect particular file formats or subdirectory layouts.
 Language-specific managers make more assumptions in that regard, and also
 support customizing the installation directory prefix, which is a necessity
 for running as a non-privileged user.
 Some system-wide managers, like Nix and GoboLinux support per-user installation
s, but that often requires patching packages for removing hardcoded pathnames.
 Homebrew supports this feature as a tool, but their packages are not adapted
 for that, so per-user installations are discouraged.
\end_layout

\begin_layout Section
Integration between languages vs.
 integration between package managers
\end_layout

\begin_layout Standard
Programming languages, both general-purpose and domain-specific, frequently
 have points of integration between each other, in the form of foreign function
 interfaces (FFIs).
 Code written in one language can frequently call into code written in another
 language, sometimes with some adapter code in between.
 Domain-specific languages are in fact frequently embedded in general-purpose
 languages and in programs.
 Programming languages can also integrate between each other through common
 calling and linking conventions.
\end_layout

\begin_layout Standard
The same is not true of general-purpose and domain-specific package managers.
 Integration between two package managers is almost unheard of, even when
 they may be found on the same system.
 Instead, a subset of packages distributed through a domain-specific package
 manager are repackaged in the format of the general-purpose system.
 These packages are fully integrated with the broader system and fully detached
 from the domain-specific manager.
 Packages that were not repackaged are still available by using the domain-speci
fic system, but others are available twice, potentially in different versions
 and with different configurations.
 Debian experimented with a 
\family typewriter
rubygems-integration
\family default
 package that provided a limited connection between APT and RubyGems, allowing
 Debian packages of individual RubyGems to satisfy dependencies in the gem
 tool, but encountered nontrivial complications in doing so
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "debian-ruby-trouble,debian-ruby-packaging"
literal "true"

\end_inset

.
 Debian has not yet pursued even this level of integration for other widely-used
 domain-specific package managers, and the integration it has for RubyGems
 is ad-hoc and highly specialized.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GoboLinux-Aliens"

\end_inset

 we discuss our attempt at deeper integration in GoboLinux, but we are aware
 of no other such integrations beyond what Debian performs.
\end_layout

\begin_layout Standard
A weaker form of one-way integration between package managers occurs when
 the system-wide manager uses the language-specific package manager merely
 as a build system.
 An example is the use of LuaRocks by Buildroot 
\begin_inset CommandInset citation
LatexCommand cite
key "buildroot"
literal "true"

\end_inset

.
 Buildroot is a system for compiling full-system images for embedded environment
s, which has its own package specification format.
 It uses LuaRocks as a build tool: the Buildroot specification scripts launch
 LuaRocks to generate Lua modules and then collect and integrate them to
 the system.
\end_layout

\begin_layout Section
Experiences with package management
\end_layout

\begin_layout Standard
In the following section, we share some of our experiences, each case study
 dealing with one the three aspects of package management design outlined
 above.
\end_layout

\begin_layout Subsection
GoboLinux
\begin_inset CommandInset label
LatexCommand label
name "subsec:GoboLinux"

\end_inset


\end_layout

\begin_layout Standard
GoboLinux 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2002WSL"
literal "true"

\end_inset

 is a Linux distribution based on the concept of installing each package
 in a separate installation prefix.
 Introduced in 2002, it was the first Linux distribution to be entirely
 based on a filesystem-oriented approach to package management
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While GoboLinux remained a research distribution with a niche community,
 its design proved influential, as its filesystem-oriented approach was
 used as a basis for the design of Homebrew, the most popular package manager
 in macOS today, as noted in its original documentation: 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/Homebrew/legacy-homebrew/tree/89283db693e9380ccc2e4abc4fa0ad14
b4790202
\end_layout

\end_inset


\end_layout

\end_inset

.
 Each program is installed under its own versioned directory, such as 
\family typewriter
/Programs/Bash/4.3.28
\family default
 and 
\family typewriter
/Programs/GTK+/3.16.0
\family default
.
 This direct mapping of the package structure to the directory layout allows
 one to inspect the system using standard Unix commands.
 For example, to get a list of installed packages, one only needs to issue
 
\family typewriter
ls /Programs
\family default
.
\end_layout

\begin_layout Standard
As well as the individual program trees, a tree of symbolic links called
 
\family typewriter
/System/Index
\family default
 collects references to the files from every program in the system.
 A single directory contains symlinks matching the structure of the 
\begin_inset Quotes eld
\end_inset


\family typewriter
lib
\family default

\begin_inset Quotes erd
\end_inset

 directory of every program, paralleling the contents of 
\family typewriter
/usr/lib
\family default
 in a conventional layout.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gobofs"

\end_inset

 illustrates this structure.
 In this way only a single entry in PATH is needed to find every executable
 and libraries can be loaded using the ordinary linker mechanisms without
 further configuration.
 An additional layer of fixed symlinks provides backwards compatibility
 with the conventional Filesystem Hierarchy Standard
\begin_inset CommandInset citation
LatexCommand cite
key "fhs"
literal "true"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Since packages become self-described through the GoboLinux filesystem hierarchy,
 the distribution features its own set of system management tools built
 around scripting languages.
 At first, these scripts automated tasks such as the installation of new
 packages (simply compressed tar archives) and their 
\begin_inset Quotes eld
\end_inset

activation
\begin_inset Quotes erd
\end_inset

 in the system (namely, the creation of symbolic links to their libraries,
 headers, executables, and manuals) as well as their removal (achieved by
 deleting their directory and the now-broken symbolic links).
 Over time, these scripts inevitably became more complex as they were integrated
 with other system tools and served as the pillars for 
\emph on
Compile
\emph default
, GoboLinux's build system.
\end_layout

\begin_layout Plain Layout
Taking inspiration from Gentoo's Portage system (which was itself inspired
 from BSD Ports) 
\begin_inset CommandInset citation
LatexCommand cite
key "Thiruvathukal2004Gentoo"
literal "true"

\end_inset

, Compile makes use of recipes that describe how to fetch the source code
 of a piece of software and the sequence of commands required to build and
 install it.
 Because recipes are frequently hand-written, it is essential to make them
 as simple as possible so that users are encouraged to contribute to the
 distribution's ecosystem.
 The approach adopted by Compile is to embed as much code as possible in
 its build systems' backends (e.g.
 Autoconf, Makefile, xmkmf, CMake), allowing the majority of recipes to
 be described with little more than a couple of lines.
 More complex build cases can be described by extending recipes with regular
 shell scripting.
 Compile can also enable the installation of packages through third-party
 package managers.
 More details of that feature are given in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:GoboLinux-Aliens"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In its original design, packages compiled for GoboLinux targeted their versioned
 directory during compilation.
 That made them aware of the modified filesystem structure, and often required
 configuration contortions and also workarounds to handle the management
 of files that were designed to be shared between packages.
 In a later revision, GoboLinux switched to compilation targeting 
\family typewriter
/usr
\family default
 and installation to the per-program location.
 Through this structure, even though packages are organized in self-contained
 directories under 
\family typewriter
/Programs
\family default
, applications find their files through the traditional Unix hierarchy,
 as 
\family typewriter
/usr
\family default
 is a symbolic link to 
\family typewriter
/System/Index
\family default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement t
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="45page%">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/hisham/projects/gobolinux/paper/gobo_systemindex.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(a) The filesystem is indexed with the use of 
\begin_inset Newline newline
\end_inset

directories and symbolic links.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /Users/hisham/projects/gobolinux/paper/gobo_programs.eps
	scale 60

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(b) Versioned directory tree.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:gobofs"

\end_inset

GoboLinux file system hierarchy
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
The mostly declarative style of GoboLinux recipes proved to be a success
 among users and gave us greater freedom when modifying the build process.
 We made major changes to the system's directory layout between releases
 014 and 015 of the distribution, and the use of high-level descriptions
 and our cautious avoidance of hardcoded paths allowed us to reuse the majority
 of recipes with no changes.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW, moved from 2.0
\end_layout

\end_inset

parts of the Unix FS hierarchy which assume a single directory: /usr/share/icons
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
effect this had on share/ in Gobo
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
having to symlink /P/Foo/x.y/share into /S/L/share
\end_layout

\begin_layout Itemize
launching helper indexing such as gtk-update-icon-cache upon each installation
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW
\end_layout

\end_inset

discuss symlinks
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

virtualized
\begin_inset Quotes erd
\end_inset

 Unix directories of GoboLinux avoid some compatibility issues that affect
 other distributions: all executables appear at the same time in /bin, /sbin,
 /usr/bin and so on.
\end_layout

\end_deeper
\begin_layout Itemize
the build system, the tooling for generating packages, is the central piece
 of a package management system.
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
not clear at first, but looking at package management systems they all integrate
 the build process.
 Why?
\end_layout

\end_deeper
\begin_layout Itemize
Discuss the challenges of GoboLinux through the prism of its build system
 (?)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Tried to make it easy for users to build packages.
\end_layout

\begin_layout Itemize
Took inspiration from systems such as Gentoo, which was itself inspired
 from BSD Ports.
\end_layout

\begin_layout Itemize
aim was to make the simple cases super-simple (like a 3-line script) and
 the complex cases possible (leveraging the generality of shell scripts)
\end_layout

\begin_layout Itemize
This worked up to a point.
 Eventually, started requiring more and more metadata, even for the so-called
 simple cases.
\end_layout

\begin_layout Itemize
Further, this metadata had to be integrated with the deployed system.
\end_layout

\begin_layout Itemize
The ArchLinux build system seems to be a modern-day successor of this style
 of build system in the Linux space.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW
\end_layout

\end_inset

tie in with the discussion of above section about includes? Gobo pre-/S/I
 didn't need versioned includes when applications detect the install prefix
 of libraries they depended on (e.g.
 via pkgconfig); with /S/I, pkgconfig will return includedir as /usr/include,
 so this becomes an issue: the recipe needs to point the conflicting program
 to /P/Foo/x.y/include, or the user needs to temporarily symlink the desired
 version (which is more fragile).
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Still, the compatibility gains for maintenance greatly outweigh the losses,
 of course.
\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
LuaRocks
\end_layout

\begin_layout Standard
LuaRocks 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"
literal "true"

\end_inset

 is a package manager for the Lua ecosystem.
 It was developed building on our previous experience writing package management
 tools for GoboLinux and adapting it to the realities of a language-specific
 manager.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
The package specification format (
\emph on
rockspec
\emph default
) was largely influenced by GoboLinux, and LuaRocks pushes the use of declarativ
e specifications even further.
 While the 
\family typewriter
.rockspec
\family default
 files themselves are actually Lua scripts, LuaRocks loads them using a
 restricted execution environment that disables the Lua standard libraries;
 they essentially consist of variable declarations, describing the package
 via Lua tables (Lua's single data structure, which combines numeric and
 associative arrays)
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR has a plugin-based build system like Gobo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Another design feature inherited from GoboLinux was the support for multiple
 build back-ends.
 In most language ecosystems, at any point in time a single build tool is
 well-established as a standard (such as 
\family typewriter
easy_install
\family default
 and later 
\family typewriter
pip
\family default
 for Python, Rake for Ruby, ExtUtils::MakeMaker and later Module::Build
 for Perl).
 In the Lua world, by the time LuaRocks was conceived, in spite of several
 contenders, there was no clear winner as a standard build tool.
 To deal with the variety of build systems, OS-level package managers typically
 let developers call their preferred build tools explicitly in imperative
 scripts.
 LuaRocks attempted to solve this in a more controlled manner, with a system
 of plugins for the various tools, akin to the one used in GoboLinux.
 In LuaRocks, each plugin is implemented as a Lua module, selected through
 an entry in the rockspec.
 For example, using 
\family typewriter
build.type="cmake"
\family default
 causes LuaRocks to invoke CMake with the appropriate arguments.
 We also included a simple built-in build system, invoked via 
\family typewriter
build.type="builtin"
\family default
, which is able to install Lua files and portably compile C code into Lua
 modules.
 This proved a success among developers: at the time of this writing, 75%
 of all packages in the LuaRocks repository use the built-in build system.
\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR supports relocatable packages
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
LuaRocks installs all packages into a sandbox directory and later moves
 them to their final destinations.
 The actual installation prefix is never told to the build system under
 execution.
 This prevents a package from hardcoding its own installation directory
 in its source code.
 While the ability to do this is a feature sometimes requested by developers
 (as it would make it easier to load asset files, for example), disallowing
 hardcoded paths ensures that every package built is relocatable.
 Having fully relocatable packages is rare on Unix, but is an expected feature
 on Windows.
 Having to cater to such conflicting requirements is a constant in writing
 portable software; to alleviate the issue of finding asset files, one of
 the authors developed a Lua module called 
\family typewriter
datafile
\family default
 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://github.com/hishamhm/datafile
\end_layout

\end_inset

, also available via 
\family typewriter
luarocks install datafile
\end_layout

\end_inset

, which resolves directory locations portably at run-time.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR changed its directory layout like Gobo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
went from filesystem-oriented to database-oriented
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
TODO illustrate with figures
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The design changes that LuaRocks underwent were due to lessons learned on
 the specificities of language-specific package management.
 The original design of LuaRocks was filesystem-oriented, like GoboLinux.
 LuaRocks included then a custom wrapper for Lua's 
\family typewriter
require()
\family default
 function, much like RubyGems.
 However, many Lua users perceived the wrapper as tampering with a standard
 library function, and disliked having to perform an initial setup in their
 scripts for using modules installed via LuaRocks 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Since Ruby 1.9, the interpreter preloads the 
\family typewriter
rubygems
\family default
 module automatically; in prior versions uses had to add 
\family typewriter
require 'rubygems'
\family default
 explicitly.
 This was never an option for Lua due to the language's minimalistic design,
 rendering LuaRocks as a strictly optional component.
\end_layout

\end_inset

.
 For LuaRocks 2.0, the design was changed to be database-oriented, so that
 Lua modules could be installed into a typical Unix-like layout that matched
 the default configuration of the Lua interpreter's package loader.
 With all packages installed under a single directory, a database had to
 be put in place matching files to packages.
 Supporting multiple versions of the same package installed at the same
 time is still possible, but requires the now-optional custom package loader,
 which produces versioned filenames when the dependency graph requires an
 old version of a module.
 This language-specific runtime adjustment allows avoiding the issue with
 filename conflicts, so common with database-oriented designs â€” a luxury
 that operating system package managers cannot afford so easily.
\end_layout

\begin_layout Standard
Having a high-level declarative specification allowed us to make such radical
 changes to the installation layout easily.
 Since LuaRocks produces relocatable packages, it does not provide to rockspec
 files any knowledge of the final directory structure.
 This allowed all existing rockspecs could be used in the new directory
 layout without any changes.
 This level of information hiding was only possible because we were dealing
 with a language-specific manager, where we could make assumptions about
 the contents of files (Lua source code and binary dynamic libraries) and
 how they would be used (as command-line scripts or loaded by Lua through
 its package loader system).
\end_layout

\begin_layout Subsection
GoboLinux Aliens
\begin_inset CommandInset label
LatexCommand label
name "subsec:GoboLinux-Aliens"

\end_inset


\end_layout

\begin_layout Standard
In GoboLinux we researched the idea of building a foreign function interface
 (FFI) of sorts into our general-purpose package manager, which we called
 Aliens
\begin_inset CommandInset citation
LatexCommand cite
key "Homer2010LCA"
literal "true"

\end_inset

.
 Aliens provides an API to write shims that connect the general-purpose
 system package manager with domain-specific package managers.
\end_layout

\begin_layout Standard
With Aliens, packages in the general-purpose manager may express a dependency
 on a package provided by a supported domain-specific manager: for example,
 a package that requires the Perl 
\family typewriter
XML::Parser
\family default
 module, available from CPAN, can express a dependency 
\begin_inset Quotes eld
\end_inset


\family typewriter
CPAN:XML::Parser >= 2.34
\family default

\begin_inset Quotes erd
\end_inset

.
 The Aliens system directs such a dependency to a translating shim, which
 uses the CPAN tool to confirm whether it is satisfied, to install the package
 (and its dependencies) if required, and to upgrade it, communicating any
 necessary information back to the general-purpose manager.
 The shim can then make symbolic links for any binaries or native libraries
 that have been installed.
 Any package in one of the supported domain-specific managers is automatically
 available in this way, without creating wrapper packages.
\end_layout

\begin_layout Standard
The domain-specific managers themselves are not modified in this process.
 Each system is given complete control of a directory tree, and the relevant
 languages configured to search in that tree.
 This protects against changes in the functioning of the third-party systems,
 and allows users to access them directly as well.
 A drawback, however, is that the domain-specific managers do not have reciproca
l access to the wider system: installing a RubyGem that depends on a native
 library will not innately result in the native dependency being satisfied.
 The cross-platform nature of these systems makes even specifying such informati
on in a machine-readable way difficult, although some, notably LuaRocks,
 make the attempt.
\end_layout

\begin_layout Standard
Not all domain-specific package managers lend themselves to this integration.
 Some are resistant to placing their files within a restricted directory
 tree, preferring to install into the global filesystem hierarchy where
 they may interfere with each other and the system, while others do not
 mechanize well.
 This limited coverage is an additional drawback of the Aliens approach,
 but one that is limited to failing to solve an existing problem, rather
 than creating a new one.
 As with programming languages, a consensus implementation platform would
 inevitably be simpler, but social and technical factors make it impractical.
 FFIs, and Aliens, attempt to bridge the gap, with reasonable success.
\end_layout

\begin_layout Standard
\begin_inset VSpace -0.3em
\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
In this paper, we presented our practical experiences in the development
 and maintenance of a system-wide package manager for a Linux distribution
 and a portable package manager for a scripting language, and an analysis
 of the landscape of existing methodologies for package management.
 
\end_layout

\end_inset

Package management is an area that is notably neglected in academic studies,
 but is one of practical impact in the design of modern operating systems
 and module systems for programming languages.
 In the realm of programming languages, we have useful ways to categorize
 languages.
 Package management even lacks common terminology, and each new system faces
 the same design issues time and again, even as we move to containers and
 orchestration systems 
\begin_inset CommandInset citation
LatexCommand citep
key "helm"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
As we categorize package management systems, we conclude that filesystem-oriente
d designs are preferrable as they tend to be less susceptible to conflicts,
 but they require some level of control on runtime lookup.
 We observe that this control exists when language-specific package managers
 are bundled with the language environment, as is the case with npm for
 node.js and RubyGems for Ruby.
 These managers were free to adopt filesystem-oriented designs since they
 adjusted their module loaders accordingly.
 The other way to exert this control over run-time lookup is to employ a
 system-wide lower-level solution as we did in GoboLinux with the 
\family typewriter
/System/Index
\family default
 tree of symbolic links or in the stowfs filesystem virtualization proposed
 for GNU Hurd 
\begin_inset CommandInset citation
LatexCommand citep
key "stow"
literal "false"

\end_inset

.
 Database-oriented designs, on the other hand, are more generally applicable,
 but are more opaque to their users and are more prone to package conflict
 and file-to-package synchronization issues.
 For these reasons, we advocate filesystem-oriented systems in general,
 but we also recognize that there are situations where a database-oriented
 solution works best to preserve compatibility with the ecosystem at play,
 as was the case with LuaRocks.
\end_layout

\begin_layout Standard
Our classification of package managers as language-agnostic and language-specifi
c highlighted the complementary qualities of these two classes of managers.
 The existence of language-specific package managers distributes integration
 efforts, as upstream module developers are often the package integrators
 themselves.
 This allows scaling repositories way beyond what is possible through the
 work of OS distribution maintainers, but also generates some tension between
 the language and distribution communities as perceived duplicate work and
 incompatibilites happen.
 Through our experience in both ends of the spectrum of package management
 â€” from low-level distribution management in GoboLinux to high-level language
 modules in LuaRocks â€” we observed a necessity for these different levels
 of system organization to recognize each other and aim for cooperation.
 Package managers do not exist on their own, but are part of an ecosystem
 in which other package managers often take part.
 We shared our experience in progressing on this direction with the GoboLinux
 Aliens project, and we plan to further pursue FFI-style package management
 interoperability.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
refname}{REFERENCES}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "gobo"
options "wileyj"

\end_inset


\end_layout

\end_body
\end_document
