#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{usenix,url}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 3cm
\rightmargin 3cm
\bottommargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Understanding package management through the lens of programming languages
\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\backslash
rm 
\end_layout

\end_inset

Hisham Muhammad
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

PUC-Rio
\begin_inset Newline newline
\end_inset

Rio de Janeiro, Brazil
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and{
\backslash
rm 
\end_layout

\end_inset

Lucas Correia Villa Real
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

IBM Research
\begin_inset Newline newline
\end_inset

São Paulo, Brazil
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and{
\backslash
rm 
\end_layout

\end_inset

Michael Homer
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset

Victoria University of Wellington
\begin_inset Newline newline
\end_inset

Wellington, New Zealand
\end_layout

\begin_layout Abstract
This is an abstract, yet to be written.
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Package management is an area that lies somewhere in the border between
 programming languages, operating systems and system administration.
 For this reason, it seems to be overlooked by all three fields as an implementa
tion issue.
 In the meantime, package management keeps growing in complexity.
 New languages, new deployment models and new portability requirements,
 all give rise to new package management systems.
 Further, this is not simply a matter of competing implementations: modern
 complex environments often require several package managers to be used
 in tandem.
\end_layout

\begin_layout Standard
For example, when writing JavaScript web applications on a Mac environment,
 a developer may require using Bower 
\begin_inset CommandInset citation
LatexCommand cite
key "bower"

\end_inset

, a package manager for client-side JavaScript components.
 Bower is installed using 
\family typewriter
npm
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "npm"

\end_inset

, a package manager for 
\family typewriter
node.js
\family default
 
\begin_inset CommandInset citation
LatexCommand cite
key "nodejs"

\end_inset

, a JavaScript environment.
 On a Mac system, the typical way to install command-line tools such as
 
\family typewriter
npm
\family default
 is via either Homebrew 
\begin_inset CommandInset citation
LatexCommand cite
key "homebrew"

\end_inset

 or MacPorts 
\begin_inset CommandInset citation
LatexCommand cite
key "macports"

\end_inset

, the two most popular general-purpose package managers for Mac OSX.
 This is not a deliberately contrived example; it is the regular way to
 install development modules for a popular language in a modern platform.
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset citation
LatexCommand cite
key "Burns2012Deploying"

\end_inset

 we have another example of a typical software stack, where a deployment
 and management scenario for Ruby on Rails applications is described combining
 a number of tools.
 It uses Vagrant 
\begin_inset CommandInset citation
LatexCommand cite
key "Hashimoto2013Vagrant"

\end_inset

 for virtual machine management; Puppet 
\begin_inset CommandInset citation
LatexCommand cite
key "Arrundel2011Puppet"

\end_inset

 for editing system configuration files and driving the system-wide package
 manager on servers; Capistrano for deploying the Ruby on Rails application,
 including installing Ruby scripts and migrating database tables, driving
 RubyGems, the language-specific package manager for Ruby modules (with
 Bundler to mitigate module version conflicts); and RVM for managing conflicting
 versions of Ruby itself.
 It is interesting to note the number of different tools being used on top
 of each other to manage containment and compatibility issues on various
 layers; and again, this is a typical, realistic scenario.
\end_layout

\begin_layout Standard
The combinations of package managers change as we move to a different operating
 system or use a different language.
 Learning one's way through a new language or system, nowadays, includes
 learning one or more packaging environments.
 As a developer of modules, this includes not only using package managers
 but also learning to deploy code using them, which includes syntaxes for
 package specification formats, dependency and versioning rules and deployment
 conventions.
 Simply ignoring these environments and managing modules and dependencies
 by hand is tempting, but the complexity of heterogeneous environments and
 keeping track of dependency updates can become burdensome — all these package
 managers were created to solve pratical problems which the developer would
 have to otherwise directly handle, after all.
 Another alternative that is often proposed, especially by users of operating
 systems that feature a system-provided package manager (as is the case
 of most Linux distributions), is to avoid using multiple package managers
 and use a single general-purpose package manager.
 This is, of course, as much as a solution as trying to make everyone agree
 on a single programming language, and this is the first of various analogies
 between package management and programming languages that we will make
 throughout this paper.
 The result is that the ecosystem is not getting any simpler, and at first
 glance it seems that package management is indeed a largely unsolved problem.
\end_layout

\begin_layout Standard
However, maybe the statement 
\begin_inset Quotes eld
\end_inset

package management is an unsolved problem
\begin_inset Quotes erd
\end_inset

 simply does not make sense, and is akin to saying that 
\begin_inset Quotes eld
\end_inset

programming languages are an unsolved problem
\begin_inset Quotes erd
\end_inset

.
 In the programming languages world we accept that the multitude of languages
 is a given.
 Beyond that, we understand that there are families of languages with different
 paradigms, with well-known tradeoffs.
 We also accept that there is room for domain-specific languages (DSLs)
 and for general-purpose languages.
 Most importantly, we know how to set boundaries for each language and how
 to make DSLs and general-purpose languages interact.
\end_layout

\begin_layout Standard
We argue that all of these observations can be made with regard to package
 management as well.
 In this paper, we discuss how these observations map from the world of
 programming languages to that of package managers.
 Most existing package management systems, however, are still oblivious
 to the fact that they exist as part of a larger ecosystem, with parts of
 it handled by other package managers.
 By discussing how programming languages deal with these issues, we point
 to directions on how package managers could follow their example, drawing
 on our experiences developing both a system-wide package manager 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2002WSL,Homer2010LCA"

\end_inset

 and a language-specific package manager 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"

\end_inset

.
 
\end_layout

\begin_layout Section
Paradigms of package management: filesystem-oriented vs.
 database-oriented
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Filesystem-oriented
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Database-oriented
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-agnostic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Homebrew (Mac OS X)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Nix
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Windows Installer
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
GoboLinux
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
RPM (RedHat/Fedora/etc.)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
dpkg/apt (Debian/Ubuntu/etc.)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Pacman (ArchLinux)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-specific
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
npm (server-side JavaScript)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Bower (client-side JavaScript)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
LuaRocks 1.x (Lua)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Cabal (Haskell)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
LuaRocks 2.x (Lua)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:pm-taxonomy"

\end_inset

A package manager taxonomy
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is customary to organize the landscape of programming languages into
 paradigms, such as imperative, functional, object-oriented, and so on.
 These paradigms describe the core conceptual frameworks on top of which
 languages are designed.
 The paradigms a language is categorized into inform users about particular
 design choices, and with these choices come design trade-offs.
 Many of these trade-offs have been studied and are well understood.
 A notable example is the Expression Problem 
\begin_inset CommandInset citation
LatexCommand cite
key "Wadler1998EP,Krishnamurthi:1998:SOF:646155.679709"

\end_inset

, which poses a trade-off between traditional functional and object-oriented
 approaches when extending code via separate compilation units: in functional
 programming, it is easy to add new operations to a data type (adding new
 functions), but it is not possible to extend the type (adding new cases
 to the algebraic data type) without editing the original code; in OOP,
 it is easy to extend the type (adding a subclass), but it is not possible
 to add new operations to an existing type (adding new methods to the original
 class) without editing code.
 Once this trade-off is understood, it becomes easier to propose solutions
 to mitigate it, such as open classes 
\begin_inset CommandInset citation
LatexCommand cite
key "Clifton:2000:MMO:353171.353181"

\end_inset

 and mixins 
\begin_inset CommandInset citation
LatexCommand cite
key "Flatt:1998:CM:268946.268961"

\end_inset

.
\end_layout

\begin_layout Standard
In the world of package managers, we can also identify general paradigms,
 by looking at their core concepts and design trade-offs.
 Package managers are programs that map relations between files and packages
 (which correspond to sets of files), and between packages (dependencies),
 allowing users to perform maintainance of their systems in terms of packages
 rather than at the level of individual files.
 The central design choice in a package manager, therefore, is how to perform
 those mappings.
\end_layout

\begin_layout Standard
There are two approaches on how to map files to packages: the mapping can
 be either 
\emph on
internal
\emph default
 or 
\emph on
external
\emph default
 to the hierarchical structure of directories where the files reside.
 As this choice embodies a series of trade-offs and is the single decision
 that affects the design and implementation of a package manager the most,
 we identify these as two paradigms of package management.
 When the mapping is internal to the file hierarchy structure, we say that
 package management is 
\emph on
filesystem-oriented
\emph default
.
 When it is external to the hierarchy of files being managed, the mapping
 needs to be stored elsewhere: on a database, or an equivalent structure
 that acts as one.
 We say in these cases that management is 
\emph on
database-oriented
\emph default
.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Not sure at what point this paragraph should fit.
\end_layout

\end_inset

Initially it may seem that this is an implementation detail, and that this
 distinction is, or should be, transparent to users of package managers.
 As long as they can type a command to install a package and then launch
 the program or load the library, how the manager keeps its consistency
 is irrelevant.
 While this is true for end-users installing packages and using applications
 and libraries, it is not true for another category of users of package
 managers: those who do the packaging of programs.
 In other words, this is akin to saying that on one hand end-users of applicatio
ns shouldn't care what language they are written in, but on the other hand
 the language paradigm affects those who write programs greatly.
\end_layout

\begin_layout Standard
The major trade-off between the filesystem-oriented and the database-oriented
 approach is 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Unfinished sentence!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In filesystem-oriented managers the mapping of files to packages is simple.
 File conflicts are naturally avoided by storing files of different packages
 in separate subtrees.
 Versioning conflicts between variants of the same package can also be handled
 via the tree structure.
 The structure also becomes more transparent to users, which can simplify
 their experience.
 The run-time lookup of files by applications, however, can be complicated,
 if they are oblivious to the structure defined by the package manager.
 Applications must either agree beforehand to this structure (which might
 be an option in domain-specific environments), or the package manager has
 to do extra work to configure them to use the structure; in the worst case,
 patching them.
\end_layout

\begin_layout Standard
Conversely, in database-oriented managers the mapping of files to packages
 is more complicated.
 Applications may install files wherever they please, and the package manager
 needs to keep track.
 This includes handling potential conflicts if two packages want to use
 the same pathname.
 Database-oriented systems will usually report on these conflicts and forbid
 them.
 It is up to the integrator (such as a distribution developer) who is building
 packages to resolve the conflict somehow.
 Also, the package manager needs to verify that the database and the contents
 of the filesystem remain in sync, which is trivial in the filesystem-oriented
 approach.
 The run-time lookup of files on database-oriented systems, on its turn,
 is greatly simplified.
 In most cases it will be a non-issue, since each file is in the location
 the application expected it to be in the first place.
 However, it does become an issue when the file has been relocated by the
 integrator who built the package, perhaps for solving conflicts.
\end_layout

\begin_layout Standard
Repository maintainers of database-oriented package managers often solve
 versioning conflicts by resorting to filesystem-oriented approaches.
 For example, the maintainer of Debian packages for the Lua virtual machine
 patches its Makefile to install C headers under versioned directories such
 as 
\family typewriter
/usr/include/lua5.3
\family default
, to avoid conflicts of simultaneous Lua versions in the system installing
 
\family typewriter
lua.h
\family default
.
 Such changes propagate to users of these packages: Lua-based software such
 as LuaRocks 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"

\end_inset

 and Prosody 
\begin_inset CommandInset citation
LatexCommand cite
key "prosody"

\end_inset

 include code in their installation scripts specifically to handle Debian
 locations.
 Meanwhile, FreeBSD uses 
\family typewriter
/usr/include/lua53
\family default
 and NetBSD uses 
\family typewriter
/usr/include/lua-5.3
\family default
.
 To reduce this kind of incompatibility among downstream distributors, many
 upstream maintainers adopt hierarchical versioning structures themselves:
 C headers for Python, for example, install into versioned directories such
 as 
\family typewriter
/usr/include/python2.7
\family default
 by default in every system.
 It is unclear, however, which packages are the ones where users will desire
 to keep simultaneously installed versions and which are not; one might
 ask why 
\emph on
all
\emph default
 C headers aren't installed in a versioned way.
 In fact, when we look at Unix shared libraries, we see that this is the
 case: the standard practice is to install libraries in versioned files
 such as libfoo.so.1, with a libfoo.so symbolic link for user convenience.
 Note that, as typical of filesystem-oriented approaches, there needs to
 be some cooperation for run-time lookup, and indeed the dynamic linker
 is aware of this structure and makes use of versioned filenames.
\end_layout

\begin_layout Itemize
Practical instances of this fs vs db trade-off:
\end_layout

\begin_deeper
\begin_layout Itemize
databases involved in runtime lookup: gtk icon cache, Haskell db updates,
 etc.
\end_layout

\begin_layout Itemize
pkg-config, how does it fit?
\end_layout

\end_deeper
\begin_layout Itemize
How to handle runtime lookup in the filesystem paradigm:
\end_layout

\begin_deeper
\begin_layout Itemize
environment variables, index directories with symlinks
\end_layout

\begin_layout Itemize
changes in filesystems to better support the filesystem paradigm? (union
 mounts, etc)
\end_layout

\end_deeper
\begin_layout Itemize
related work outside of 
\begin_inset Quotes eld
\end_inset

classic
\begin_inset Quotes erd
\end_inset

 Unix: appdirs, Windows, Plan 9.
\end_layout

\begin_layout Itemize
filesystem paradigm in Unix:
\end_layout

\begin_deeper
\begin_layout Itemize
/opt: early example of filesystem-oriented management
\end_layout

\begin_layout Itemize
parts of the FS hierarchy which use the filesystem paradigm: /usr/share/appname
\end_layout

\end_deeper
\begin_layout Itemize
Being database-oriented does not imply an opaque, binary database format.
 LuaRocks 2.x uses a set of Lua tables (in 
\family typewriter
.lua
\family default
 source format) as its database.
 ArchLinux keeps its database as a tree under 
\family typewriter
/var/lib/pacman/local
\family default
, with one subdirectory per package, containing text files that list which
 files belong to which package, as well as other metadata.
\end_layout

\begin_deeper
\begin_layout Itemize
Makefiles with install and uninstall rules in ports: early example of database
 paradigm?
\end_layout

\end_deeper
\begin_layout Itemize
other instances of filesystem vs database paradigm:
\end_layout

\begin_deeper
\begin_layout Itemize
sysv and BSD init versus systemd
\end_layout

\begin_layout Itemize
Mac OSX equivalent
\end_layout

\begin_layout Itemize
/etc text-based config files vs.
 gconf
\end_layout

\begin_layout Itemize
Windows registry.
\end_layout

\end_deeper
\begin_layout Itemize
Explain Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:pm-taxonomy"

\end_inset

.
\end_layout

\begin_layout Subsection
GoboLinux
\end_layout

\begin_layout Standard
GoboLinux 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2002WSL"

\end_inset

 is a Linux distribution based on the concept of installing each package
 in a separate installation prefix.
 It was the first Linux distribution to be entirely based on a filesystem-orient
ed approach to package management.
 Each program is installed under its own versioned directory, such as 
\family typewriter
/Programs/Bash/4.3.28
\family default
 and 
\family typewriter
/Programs/GTK+/3.16.0
\family default
.
 This direct mapping of the package structure to the directory layout allows
 one to inspect the system using standard Unix commands.
 For example, to get a list of installed packages, one only needs to issue
 
\family typewriter
ls /Programs
\family default
.
\end_layout

\begin_layout Standard
As well as the individual program trees, a tree of symbolic links also exists
 created collecting references to the files of every program in the system
 together.
 A single directory contains symlinks matching the structure of the 
\begin_inset Quotes eld
\end_inset


\family typewriter
lib
\family default

\begin_inset Quotes erd
\end_inset

 directory of every program, paralleling the contents of 
\family typewriter
/usr/lib
\family default
 in a conventional layout.
 In this way only a single entry in PATH is needed to find every executable
 and libraries can be loaded using the ordinary linker mechanisms without
 further configuration.
 An additional layer of fixed symlinks provides backwards compatibility
 with the conventional Filesystem Hierarchy Standard
\begin_inset CommandInset citation
LatexCommand cite
key "fhs"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Should we add a figure illustrating the GoboLinux FS layout? I think we'll
 need a more detailed description of the structure somehow.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since packages become self-described through the GoboLinux filesystem hierarchy,
 the distribution features its own set of system management tools built
 around scripting languages.
 At first, these scripts automated tasks such as the installation of new
 packages (simply compressed tar archives) and their ``activation'' in the
 system (namely, the creation of symbolic links to their libraries, headers,
 executables, and manuals) as well as their removal (achieved by deleting
 their directory and the now-broken symbolic links).
 Over time, these scripts inevitably became more complex as they became
 integrated with other system tools and served as the pillars for 
\emph on
Compile
\emph default
, GoboLinux' build system.
\end_layout

\begin_layout Standard
Taking inspiration from Gentoo's Portage system (which was itself inspired
 from BSD Ports), Compile makes use of recipes that describe how to fetch
 the source code of a piece of software and the sequence of commands required
 to build and install it.
 Because recipes are frequently hand-written, it is essential to make them
 as simple as possible so that users are encouraged to contribute to the
 distribution's ecosystem.
 The approach adopted by Compile is to embed as much code as possible in
 its build systems' backends (e.g.
 Autoconf, Makefile, xmkmf, Cmake), allowing the majority of recipes to
 be described with little more than a couple of lines.
 More complex build cases can be described by extending recipes with regular
 shell scripting.
\end_layout

\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW, moved from 2.0
\end_layout

\end_inset

parts of the Unix FS hierarchy which assume a single directory: /usr/share/icons
\end_layout

\begin_deeper
\begin_layout Itemize
effect this had on share/ in Gobo
\end_layout

\begin_deeper
\begin_layout Itemize
having to symlink /P/Foo/x.y/share into /S/L/share
\end_layout

\begin_layout Itemize
launching helper indexing such as gtk-update-icon-cache upon each installation
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW
\end_layout

\end_inset

discuss symlinks
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\begin_inset Quotes eld
\end_inset

virtualized
\begin_inset Quotes erd
\end_inset

 Unix directories of GoboLinux avoid some compatibility issues that affect
 other distributions: all executables appear at the same time in /bin, /sbin,
 /usr/bin and so on.
\end_layout

\end_deeper
\begin_layout Itemize
Our extensive use of shell scripting for system management was a sort of
 attempt to show that the system could work with 
\begin_inset Quotes eld
\end_inset

just a few scripts
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
core ideas work (the system is still driven via symlinks) but management
 scripts became complex over time
\end_layout

\end_deeper
\begin_layout Itemize
the build system, the tooling for generating packages, is the central piece
 of a package management system.
\end_layout

\begin_deeper
\begin_layout Itemize
not clear at first, but looking at package management systems they all integrate
 the build process.
 Why?
\end_layout

\end_deeper
\begin_layout Itemize
Discuss the challenges of GoboLinux through the prism of its build system
 (?)
\end_layout

\begin_deeper
\begin_layout Itemize
Tried to make it easy for users to build packages.
\end_layout

\begin_layout Itemize
Took inspiration from systems such as Gentoo, which was itself inspired
 from BSD Ports.
\end_layout

\begin_layout Itemize
aim was to make the simple cases super-simple (like a 3-line script) and
 the complex cases possible (leveraging the generality of shell scripts)
\end_layout

\begin_layout Itemize
This worked up to a point.
 Eventually, started requiring more and more metadata, even for the so-called
 simple cases.
\end_layout

\begin_layout Itemize
Further, this metadata had to be integrated with the deployed system.
 
\end_layout

\begin_layout Itemize
The ArchLinux build system seems to be a modern-day successor of this style
 of build system in the Linux space.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Note Note
status open

\begin_layout Plain Layout
NEW
\end_layout

\end_inset

tie in with the discussion of above section about includes: Gobo pre-/S/I
 didn't need versioned includes when applications detect the install prefix
 of libraries they depended on (e.g.
 via pkgconfig); with /S/I, pkgconfig will return includedir as /usr/include,
 so this becomes an issue: the recipe needs to point the conflicting program
 to /P/Foo/x.y/include, or the user needs to temporarily symlink the desired
 version (which is more fragile).
\end_layout

\begin_deeper
\begin_layout Itemize
This could be an interesting self-criticism on how Gobo became more 
\begin_inset Quotes eld
\end_inset

database-oriented
\begin_inset Quotes erd
\end_inset

 (i.e.
 more reliant on /S/I as a db index) than before.
\end_layout

\begin_layout Itemize
Still, the compatibility gains for maintenance greatly outweigh the losses,
 of course.
\end_layout

\end_deeper
\begin_layout Standard
The mostly declarative style of GoboLinux recipes proved to be a success
 among users and gave us greater freedom when modifying the build process.
 We made major changes to the system's directory layout between releases
 014 and 015 of the distribution, and the use of high-level descriptions
 and our cautious avoidance of hardcoded paths allowed us to reuse the majority
 of recipes with no changes.
\end_layout

\begin_layout Subsection
Other filesystem-oriented approaches
\end_layout

\begin_layout Itemize
Short history of alternative approaches:
\end_layout

\begin_deeper
\begin_layout Itemize
earliest related work: GNU stow, encap.
 (Our paper from Workshop em Software Livre mentions that, but we didn't
 really know about them when making Gobo)
\end_layout

\begin_layout Itemize
Zero Install (still active), Autopackage (dormant, 
\begin_inset Quotes eld
\end_inset

packages must be relocatable
\begin_inset Quotes erd
\end_inset

), 
\end_layout

\end_deeper
\begin_layout Itemize
The Nix project has been around almost as long as GoboLinux.
 NixOS is nowadays a serious contender in the world of server-oriented operating
 systems.
\end_layout

\begin_deeper
\begin_layout Itemize
virtual machines: minimalism is making its way back in OS layout design.
 (There have always been minimalistic Linux distributions, back from the
 
\begin_inset Quotes eld
\end_inset

rescue
\begin_inset Quotes erd
\end_inset

 distros such as Damn Small Linux and tomsrtbt (which would fit in a floppy!).
\end_layout

\begin_deeper
\begin_layout Itemize
CoreOS, based on Gentoo, is the current representative of the minimalistic
 server-oriented distro world.
\end_layout

\begin_layout Itemize
Ubuntu Core was recently announced, and this might be a beginning of a general
 trend of 
\begin_inset Quotes eld
\end_inset

core
\begin_inset Quotes erd
\end_inset

 OSes.
\end_layout

\begin_deeper
\begin_layout Itemize
Ubuntu Core 
\begin_inset Quotes eld
\end_inset

snappy
\begin_inset Quotes erd
\end_inset

 packages strongly resemble GoboLinux!
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Homebrew, a package manager for Mac OS X, is a successful realization of
 this idea.
 One of its original design criteria was to do package management 
\begin_inset Quotes eld
\end_inset

the GoboLinux way
\begin_inset Quotes erd
\end_inset

 [in the git history of homebrew's README.md we find them citing gobolinux]
 (so I guess that's the most widespread legacy of our work)
\end_layout

\end_deeper
\begin_layout Itemize
What do we mean by filesystem facilities: a more powerful fs would make
 things better?
\end_layout

\begin_deeper
\begin_layout Itemize
Back in 200x we mentioned [the 
\begin_inset Quotes eld
\end_inset

clueless
\begin_inset Quotes erd
\end_inset

 whitepaper] how we needed more low-level tooling from the underlying operating
 system in order to be able to realize some of the ideas of GoboLinux cleanly.
 We were asking for more abstraction and isolation in userspace: essentially
 we wanted union filesystems and possibly some sort of containers for finer-grai
ned isolation.
 Lacking those, we had to make do with chroot.
\end_layout

\begin_layout Itemize
For a while we hoped that as underlying technology matured, these ideas
 could come to fruition.
\end_layout

\begin_layout Itemize
Docker seems to be proof of that; a container-based system that greatly
 simplified application deployment.
\end_layout

\begin_layout Itemize
However, Glauber Costa, one of the developers of the Linux Containers system,
 described the limitations of that approach exposed the hackery involved
 [did he write about it somewhere?].
 Costa himself moved away from containers and joined the efforts of the
 OSv project, a minimalistic operating system targeting hypervisor-based
 architectures.
\end_layout

\end_deeper
\begin_layout Section
Language-oriented vs.
 language-agnostic package managers
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-specific managers
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Package managers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
npm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
RubyGems
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
NuGet
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
LuaRocks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Portability
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
OS-independent (all Unix, Windows)
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Installs code written in
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JS family,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
C/C++
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby, C/C++,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JVM family
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
any .NET, C++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua family, C/C++
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Files managed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JS scripts,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
JS modules
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby scripts,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Ruby modules
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
.NET and
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
native packages
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="1">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua scripts,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Lua modules
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Supports per-user install
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\size footnotesize
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<column alignment="center" valignment="top" width="10page%">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Language-agnostic managers
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Package managers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Nix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
Homebrew
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
RPM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\size footnotesize
GoboLinux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Portability
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/OSX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
OSX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/AIX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Linux/Cygwin/OSX
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Installs code written in
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
any language
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Files managed
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
all kinds
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
Supports per-user install
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
no*
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
no
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
yes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
* different installation prefixes are supported but 
\family typewriter
/usr/local
\family default
 is strongly recommended.
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:langspec-vs-langagn"

\end_inset

Contrasting language-specific and language-agnostic package managers
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the world of programming languages, there is a distinction between DSLs
 and general purpose languages.
 Categorizing languages in one camp or another is not always easy, but a
 working definition is that domain-specific languages are those designed
 with a specific application domain in mind, and general purpose languages
 are the complementary set, that is, those languages designed not with a
 particular domain in mind, but rather focusing on general areas such as
 
\begin_inset Quotes eld
\end_inset

systems programming
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
While we tend to see DSLs as smaller languages than their general-purpose
 counterparts (and in fact early literature used to term them 
\begin_inset Quotes eld
\end_inset

little languages
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Bentley:1986:PPL:6424.315691"

\end_inset

), what defines a language as being a DSL is the 
\emph on
inclusion
\emph default
 of features tailored for a domain.
 This means that a domain-specific language may end up including all features
 normally understood as those defining a general purpose language.
 MATLAB, for instance, is a complete programming language, but its wealth
 of features for numerical computing it is often regarded as being domain-specif
ic 
\begin_inset CommandInset citation
LatexCommand cite
key "Gill:2014:DLC:2611429.2617811,Fowler2005LanguageWorkbench"

\end_inset

.
\end_layout

\begin_layout Standard
In the world of package management, there is also a distinction between
 domain-specific and general purpose systems, but it is better defined.
 Language-specific managers are designed to be used in a particular 
\emph on
language ecosystem
\emph default
.
 This ecosystem usually focuses around a single language (hence the name
 
\begin_inset Quotes eld
\end_inset

language-specific
\begin_inset Quotes erd
\end_inset

), but that is not necessarily the case: environments such as .NET and the
 JVM make this evident, but other languages also grow into families: for
 example, LuaRocks was written for Lua but also supports MoonScript and
 Typed Lua; npm supports JavaScript, CoffeeScript, TypeScript and others.
 Besides, these VM-based ecosystems usually support loading native extensions,
 and therefore they must also support building and integrating libraries
 usually written in C or C++ (or, in the case of RubyGems with JRuby, Java).
 A language-specific package manager, therefore, is almost never specific
 to code written in a single language.
 Like domain-specific programming languages which are not necessarily much
 smaller than their general-purpose counterparts, the more sophisticated
 language-specific package managers are in effect general package managers
 with specific support for an ecosystem added.
 They need to build and deploy executables, native libraries and resource
 files written in different languages, keep track of installed files, check
 dependencies, perform network operations and manage remote repositories.
 Some of these tasks can be simplified due to ecosystem-specific assumptions,
 but many are equivalent in complexity to the tasks of a system-wide package
 manager.
\end_layout

\begin_layout Standard
This leads us to question why should we have language-specific managers
 at all, if they replicate so much of the work done by general-purpose package
 managers.
 Two arguments in defense of language-specific managers are scalability
 and portability.
 If we compare the number of packages provided by a typical Linux distribution
 versus the number of modules available in mature module repositories from
 scripting languages, it becomes clear that the approach of converting everythin
g into native packages is untenable: for example, while the repository for
 the Debian Linux distribution features 43,000 packages in total, the Maven
 Central repository for Java alone contains over 103,000 packages, with
 the advantage that the repository is portable to various platforms, some
 of which lacking a built-in universal package manager (Microsoft Windows
 being a notable case).
 Still, this kind of effort duplication does happen: the Debian repository
 contains 715 packages of Ruby modules; this is a far cry from the 100,000
 modules in the RubyGems repository.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:langspec-vs-langagn"

\end_inset

 contrasts language-specific and language-agnostic package managers, through
 a few examples.
 Language-specific package managers tend to be highly portable, even if
 the modules in their repositories are not.
 For example, while most packages for NuGet are Windows-specific, the manager
 itself has been ported to Unix systems via Mono; packages that do not depend
 on Windows APIs can be shared by various platforms.
 Language-agnostic managers are generally system-specific, and may present
 some degree of portability to other similar OSes.
 Note that the extent of portability of all language-agnostic managers in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:langspec-vs-langagn"

\end_inset

 is limited to specific Unix variants.
 Those managers support packaging programs written in any language and for
 that reason do not expect particular file formats or subdirectory layouts.
 Language-specific managers make more assumptions in that regard, and also
 support customizing the installation directory prefix, which is a necessity
 for running as a non-privileged user.
 Some system-wide managers, like Nix and GoboLinux support per-user installation
s, but that often requires patching packages for removing hardcoded pathnames.
 Homebrew supports this feature as a tool, but their packages are not adapted
 for that, so per-user installations are discouraged.
\end_layout

\begin_layout Subsection
LuaRocks
\end_layout

\begin_layout Standard
LuaRocks 
\begin_inset CommandInset citation
LatexCommand cite
key "Muhammad2013LuaRocks"

\end_inset

 is a package manager for the Lua ecosystem.
 It was developed building on our previous experience writing package management
 tools for GoboLinux and adapting them to the realities of a language-specific
 manager.
\end_layout

\begin_layout Standard
The package specification format (
\emph on
rockspec
\emph default
) was largely influenced by GoboLinux, and LuaRocks pushes the use of declarativ
e specifications even further.
 While the 
\family typewriter
.rockspec
\family default
 files themselves are actually Lua scripts, LuaRocks loads them using a
 restricted execution environment that disables the Lua standard libraries;
 they essentially consist of variable declarations, describing the package
 via Lua tables (Lua's single data structure, which combines numeric and
 associative arrays).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR has a plugin-based build system like Gobo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another design feature inherited from GoboLinux was the support for multiple
 build back-ends.
 In most language ecosystems, at any point in time a single build tool is
 well-established as a standard (such as 
\family typewriter
easy_install
\family default
 and later 
\family typewriter
pip
\family default
 for Python, Rake for Ruby, ExtUtils::MakeMaker and later Module::Build
 for Perl).
 In the Lua world, by the time LuaRocks was conceived, in spite of several
 contenders, there was no clear winner as a standard build tool.
 To deal with the variety of build systems, OS-level package managers typically
 let developers call their preferred build tools explicitly in imperative
 scripts.
 LuaRocks attempted to solve this in a more controlled manner, with a system
 of plugins for the various tools, akin to the one used in GoboLinux.
 In LuaRocks, each plugin is implemented as a Lua module, selected through
 an entry in the rockspec.
 For example, using 
\family typewriter
build.type="cmake"
\family default
 causes LuaRocks to invoke CMake with the appropriate arguments.
 We also included a simple built-in build system, invoked via 
\family typewriter
build.type="builtin"
\family default
, which is able to install Lua files and portably compile C code into Lua
 modules.
 This proved a success among developers: at the time of this writing, 75%
 of all packages in the LuaRocks repository use the built-in build system.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR supports relocatable packages
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LuaRocks installs all packages into a sandbox directory and later moves
 them to their final destinations.
 The actual installation prefix is never informed to the build system under
 execution.
 This prevents a package from hardcoding its own installation directory
 in its source code.
 While the ability to do this is a feature sometimes requested by developers
 (as it would make it easier to load asset files, for example), disallowing
 hardcoded paths ensures that every package built is relocatable.
 Having fully relocatable packages is rare on Unix, but is an expected feature
 on Windows.
 Having to cater to such conflicting requirements is a constant in writing
 portable software; to alleviate the issue of finding asset files, one of
 the authors developed a Lua module called 
\family typewriter
datafile
\family default
 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://github.com/hishamhm/datafile
\end_layout

\end_inset

, also available via 
\family typewriter
luarocks install datafile
\end_layout

\end_inset

, which resolves directory locations portably at runtime.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
LR changed its directory layout like Gobo
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As it also happened with GoboLinux, having a high-level description format
 allowed us to make radical changes to the installation layout once that
 proved necessary.
 Since LuaRocks does not provide to specification files any knowledge of
 the final directory structure, this change was even less impacting for
 users than the change on GoboLinux: all existing rockspecs could be used
 in the new directory layout without any changes.
 This level of information hiding, extending not only the installation prefix,
 but to all subdirectories, was only possible because we were dealing with
 a language-specific manager, where we could make assumptions about the
 contents of files (Lua source code and binary dynamic libraries) and how
 they would be later used (as command-line scripts or loaded by Lua through
 its package loader system).
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
went from filesystem-oriented to database-oriented
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The design changes that LuaRocks underwent from version 1.0 to version 2.0
 were due to lessons learned on the specificities of language-specific package
 management.
 The original design of LuaRocks was filesystem-oriented, like GoboLinux.
 Each version of an installed package was given its own directory and each
 category of files got its own subdirectory.
 For example, for module 
\family typewriter
lpeg 0.12-1
\family default
 one would store Lua files in 
\family typewriter
$PREFIX/lib/luarocks/rocks/lpeg/0.12-1/lua
\family default
.
 LuaRocks included then a custom wrapper for Lua's 
\family typewriter
require()
\family default
 function in module 
\family typewriter
luarocks.require
\family default
.
 Once this module was loaded (either via plain 
\family typewriter
require()
\family default
 or via a command-line flag), subsequent calls to 
\family typewriter
require()
\family default
 would match module names to file locations, taking into account the dependency
 trees of previously loaded modules.
 This allowed multiple versions of a module to coexist in an installation,
 and let modules load the correct versions of their dependencies transparently.
 The approach of loading a custom 
\family typewriter
require()
\family default
 function is the same as adopted by RubyGems.
 However, many Lua users perceived the wrapper as tampering with a standard
 library function, and disliked having to perform an initial setup in their
 scripts for using modules installed via LuaRocks 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Since Ruby 1.9, the interpreter preloads the 
\family typewriter
rubygems
\family default
 module automatically; in prior versions uses had to add 
\family typewriter
require 'rubygems'
\family default
 explicitly.
 This was never an option for Lua due to the language's minimalistic design,
 rendering LuaRocks as a strictly optional component.
\end_layout

\end_inset

.
 For LuaRocks 2.0, the design was changed to be database-oriented, so that
 Lua modules could be installed into a typical Unix-like layout that matched
 the default configuration of the Lua interpreter's package loader.
 Since now Lua modules from all packages were installed into a single directory
 such as 
\family typewriter
$PREFIX/share/lua/5.3
\family default
, a database had to be put in place matching files to packages.
 We kept to Lua's minimalistic approach, using a plain-text manifest file
 (loadable as Lua code) as a database.
 Supporting multiple versions of the same package installed at the same
 time is still possible, but requires the now-optional custom package loader,
 which produces versioned filenames such as 
\family typewriter
$PREFIX/lib/5.3/lpeg-0.11-1.so
\family default
 when the dependency graph requires an old version of a module.
\end_layout

\begin_layout Section
Integration between languages vs.
 integration between package managers
\end_layout

\begin_layout Standard
Programming languages, both general-purpose and domain-specific, frequently
 have points of integration between each other, in the form of foreign function
 interfaces (FFIs).
 Code written in one language can frequently call into code written in another
 language, sometimes with some adapter code in between.
 Domain-specific languages are in fact frequently embedded in general-purpose
 languages and in programs.
\end_layout

\begin_layout Standard
The same is not true of general-purpose and domain-specific package managers.
 Integration between two package managers is almost unheard of, even when
 they may be found on the same system.
 Instead, a subset of packages distributed through a domain-specific package
 manager are repackaged in the format of the general-purpose system.
 These packages are fully integrated with the broader system and fully detached
 from the domain-specific manager.
 Packages that were not repackaged are still available by using the domain-speci
fic system, but others are available twice, potentially in different versions
 and with different configurations.
 Debian experimented with a 
\family typewriter
rubygems-integration
\family default
 package that provided a limited connection between APT and RubyGems, allowing
 Debian packages of individual RubyGems to satisfy dependencies in the gem
 tool, but encountered nontrivial complications in doing so
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "debian-ruby-trouble,debian-ruby-packaging"

\end_inset

.
 Debian has not yet pursued even this level of integration for other widely-used
 domain-specific package managers, and the integration it has for RubyGems
 is ad-hoc and highly specialized.
 In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:GoboLinux-Aliens"

\end_inset

 we discuss our attempt at deeper integration in GoboLinux, but we are aware
 of no other such integrations beyond what Debian performs.
\end_layout

\begin_layout Itemize
Still, they have been successfully realized in others, such as the use of
 LuaRocks by Buildroot.
\end_layout

\begin_layout Subsection
GoboLinux Aliens
\begin_inset CommandInset label
LatexCommand label
name "sub:GoboLinux-Aliens"

\end_inset


\end_layout

\begin_layout Standard
In GoboLinux we researched the idea of building an 
\begin_inset Quotes eld
\end_inset

FFI
\begin_inset Quotes erd
\end_inset

 of sorts into our general-purpose package manager, which we called Aliens
\begin_inset CommandInset citation
LatexCommand cite
key "Homer2010LCA"

\end_inset

.
 Aliens provides an API to write shims that connect the general-purpose
 system package manager with domain-specific package managers.
\end_layout

\begin_layout Standard
With Aliens, packages in the general-purpose manager may express a dependency
 on a package provided by a supported domain-specific manager: for example,
 a package that requires the Perl 
\family typewriter
XML::Parser
\family default
 module, available from CPAN, can express a dependency 
\begin_inset Quotes eld
\end_inset


\family typewriter
CPAN:XML::Parser >= 2.34
\family default

\begin_inset Quotes erd
\end_inset

.
 The Aliens system directs such a dependency to a translating shim, which
 uses the CPAN tool to confirm whether it is satisfied, to install the package
 (and its dependencies) if required, and to upgrade it, communicating any
 necessary information back to the general-purpose manager.
 The shim can then make symbolic links for any binaries or native libraries
 that have been installed.
 Any package in one of the supported domain-specific managers is automatically
 available in this way, without creating wrapper packages.
\end_layout

\begin_layout Standard
The domain-specific managers themselves are not modified in this process.
 Each system is given complete control of a directory tree, and the relevant
 languages configured to search in that tree.
 This protects against changes in the functioning of the third-party systems,
 and allows users to access them directly as well.
 A drawback, however, is that the domain-specific managers do not have reciproca
l access to the wider system: installing a RubyGem that depends on a native
 library will not innately result in the native dependency being satisfied.
 The cross-platform nature of these systems makes even specifying such informati
on in a machine-readable way difficult, although some, notably LuaRocks,
 make the attempt.
\end_layout

\begin_layout Standard
Not all domain-specific package managers lend themselves to this integration.
 Some are resistant to placing their files within a restricted directory
 tree, preferring to install into the global filesystem hierarchy where
 they may interfere with each other and the system, while others do not
 mechanize well.
 This limited coverage is an additional drawback of the Aliens approach,
 but one that is limited to failing to solve an existing problem, rather
 than creating a new one.
 As with programming languages, a consensus implementation platform would
 inevitably be simpler, but social and technical factors make it impractical.
 FFIs, and Aliens, attempt to bridge the gap, with reasonable success.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
To-do.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "gobo"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
